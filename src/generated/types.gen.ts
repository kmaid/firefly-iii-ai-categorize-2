// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://demo.firefly-iii.org/api' | 'http://firefly.sd.internal/api' | (string & {});
};

export type AccountArray = {
    data: Array<AccountRead>;
    meta: Meta;
};

export type AttachmentArray = {
    data: Array<AttachmentRead>;
    meta: Meta;
};

export type AutocompleteAccountArray = Array<AutocompleteAccount>;

export type AutocompleteBillArray = Array<AutocompleteBill>;

export type AutocompleteBudgetArray = Array<AutocompleteBudget>;

export type AutocompleteCategoryArray = Array<AutocompleteCategory>;

export type AutocompleteCurrencyArray = Array<AutocompleteCurrency>;

export type AutocompleteCurrencyCodeArray = Array<AutocompleteCurrencyCode>;

export type AutocompleteObjectGroupArray = Array<AutocompleteObjectGroup>;

export type AutocompletePiggyArray = Array<AutocompletePiggy>;

export type AutocompletePiggyBalanceArray = Array<AutocompletePiggyBalance>;

export type AutocompleteRecurrenceArray = Array<AutocompleteRecurrence>;

export type AutocompleteRuleArray = Array<AutocompleteRule>;

export type AutocompleteRuleGroupArray = Array<AutocompleteRuleGroup>;

export type AutocompleteTagArray = Array<AutocompleteTag>;

export type AutocompleteTransactionArray = Array<AutocompleteTransaction>;

export type AutocompleteTransactionIdArray = Array<AutocompleteTransactionId>;

export type AutocompleteTransactionTypeArray = Array<AutocompleteTransactionType>;

export type AvailableBudgetArray = {
    data: Array<AvailableBudgetRead>;
    meta: Meta;
};

export type BillArray = {
    data: Array<BillRead>;
    meta: Meta;
};

export type BudgetArray = {
    data: Array<BudgetRead>;
    meta: Meta;
};

export type BudgetLimitArray = {
    data: Array<BudgetLimitRead>;
    meta: Meta;
};

export type CategoryArray = {
    data: Array<CategoryRead>;
    meta: Meta;
};

export type ConfigurationArray = Array<Configuration>;

export type CurrencyArray = {
    data: Array<CurrencyRead>;
    meta: Meta;
    links: PageLink;
};

export type CurrencyExchangeRateArray = {
    data: Array<CurrencyExchangeRateRead>;
    meta: Meta;
    links: PageLink;
};

export type LinkTypeArray = {
    data: Array<LinkTypeRead>;
    meta: Meta;
    links: PageLink;
};

export type ObjectGroupArray = {
    data: Array<ObjectGroupRead>;
    meta: Meta;
};

export type PiggyBankArray = {
    data: Array<PiggyBankRead>;
    meta: Meta;
    links: PageLink;
};

export type PiggyBankEventArray = {
    data: Array<PiggyBankEventRead>;
    meta: Meta;
    links: PageLink;
};

export type PreferenceArray = {
    data: Array<PreferenceRead>;
    meta: Meta;
    links: PageLink;
};

export type RecurrenceArray = {
    data: Array<RecurrenceRead>;
    meta: Meta;
    links: PageLink;
};

export type RuleArray = {
    data: Array<RuleRead>;
    meta: Meta;
    links: PageLink;
};

export type RuleGroupArray = {
    data: Array<RuleGroupRead>;
    meta: Meta;
    links: PageLink;
};

export type TagArray = {
    data: Array<TagRead>;
    meta: Meta;
    links: PageLink;
};

export type TransactionArray = {
    data: Array<TransactionRead>;
    meta: Meta;
    links: PageLink;
};

export type TransactionLinkArray = {
    data: Array<TransactionLinkRead>;
    meta: Meta;
    links: PageLink;
};

export type UserArray = {
    data: Array<UserRead>;
    meta: Meta;
    links: PageLink;
};

export type UserGroupArray = {
    data: Array<UserGroupRead>;
    meta: Meta;
    links: PageLink;
};

export type WebhookArray = {
    data: Array<WebhookRead>;
    meta: Meta;
    links: PageLink;
};

export type WebhookAttemptArray = {
    data: Array<WebhookAttemptRead>;
    meta: Meta;
};

export type WebhookMessageArray = {
    data: Array<WebhookMessageRead>;
    meta: Meta;
};

export type AutocompleteAccount = {
    id: string;
    /**
     * Name of the account found by an auto-complete search.
     */
    name: string;
    /**
     * Asset accounts and liabilities have a second field with the given date's account balance in the account currency or primary currency.
     */
    name_with_balance: string;
    /**
     * Is the bill active or not?
     */
    active?: boolean;
    /**
     * Account type of the account found by the auto-complete search.
     */
    type: string;
    /**
     * ID for the currency used by this account. If the user prefers amounts converted to their primary currency, this primary currency is used instead.
     */
    currency_id: string;
    /**
     * Currency name for the currency used by this account. If the user prefers amounts converted to their primary currency, this primary currency is used instead.
     */
    currency_name: string;
    /**
     * Currency code for the currency used by this account. If the user prefers amounts converted to their primary currency, this primary currency is used instead.
     */
    currency_code: string;
    /**
     * Currency symbol for the currency used by this account. If the user prefers amounts converted to their primary currency, this primary currency is used instead.
     */
    currency_symbol: string;
    /**
     * Number of decimal places for the currency used by this account. If the user prefers amounts converted to their primary currency, this primary currency is used instead.
     */
    currency_decimal_places: number;
    /**
     * ID for the currency used by this account. Even if "convertToPrimary" is on, the account currency ID is displayed here.
     */
    account_currency_id?: string;
    /**
     * Name for the currency used by this account. Even if "convertToPrimary" is on, the account currency name is displayed here.
     */
    account_currency_name?: string;
    /**
     * Code for the currency used by this account. Even if "convertToPrimary" is on, the account currency code is displayed here.
     */
    account_currency_code?: string;
    /**
     * Code for the currency used by this account. Even if "convertToPrimary" is on, the account currency code is displayed here.
     */
    account_currency_symbol?: string;
    /**
     * Number of decimal places for the currency used by this account. Even if "convertToPrimary" is on, the account currency code is displayed here.
     */
    account_currency_decimal_places?: number;
};

export type AutocompleteBill = {
    id: string;
    /**
     * Name of the bill found by an auto-complete search.
     */
    name: string;
    /**
     * Is the bill active or not?
     */
    active?: boolean;
};

export type AutocompleteBudget = {
    id: string;
    /**
     * Name of the budget found by an auto-complete search.
     */
    name: string;
    /**
     * Is the budget active or not?
     */
    active?: boolean;
};

export type AutocompleteCategory = {
    id: string;
    /**
     * Name of the category found by an auto-complete search.
     */
    name: string;
};

export type AutocompleteCurrency = {
    id: string;
    /**
     * Currency name.
     */
    name: string;
    /**
     * Currency code.
     */
    code: string;
    symbol: string;
    decimal_places: number;
};

export type AutocompleteCurrencyCode = {
    id: string;
    /**
     * Currency name with the code between brackets.
     */
    name: string;
    /**
     * Currency code.
     */
    code: string;
    symbol: string;
    decimal_places: number;
};

export type AutocompleteObjectGroup = {
    id: string;
    /**
     * Title of the object group found by an auto-complete search.
     */
    title: string;
    /**
     * Title of the object group found by an auto-complete search.
     */
    name: string;
};

export type AutocompletePiggy = {
    id: string;
    /**
     * Name of the piggy bank found by an auto-complete search.
     */
    name: string;
    /**
     * Currency ID for this piggy bank. This will always be the currency of the piggy bank, never the user's primary currency.
     */
    currency_id?: string;
    /**
     * Currency code for this piggy bank. This will always be the currency of the piggy bank, never the user's primary currency.
     */
    currency_code?: string;
    currency_symbol?: string;
    /**
     * Currency name for the currency used by this piggy bank. This will always be the currency of the piggy bank, never the user's primary currency.
     */
    currency_name?: string;
    /**
     * Number of decimal places for the currency used by this piggy bank. This will always be the currency of the piggy bank, never the user's primary currency.
     */
    currency_decimal_places?: number;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type AutocompletePiggyBalance = {
    id: string;
    /**
     * Name of the piggy bank found by an auto-complete search.
     */
    name: string;
    /**
     * Name of the piggy bank found by an auto-complete search, including the currently saved amount and the target amount.
     */
    name_with_balance?: string;
    /**
     * Currency ID for the currency used by this piggy bank. This will always be the piggy bank's currency, never the primary currency.
     */
    currency_id?: string;
    /**
     * Currency code for the currency used by this piggy bank. This will always be the piggy bank's currency, never the primary currency.
     */
    currency_code?: string;
    /**
     * Currency symbol for the currency used by this piggy bank. This will always be the piggy bank's currency, never the primary currency.
     */
    currency_symbol?: string;
    /**
     * Currency decimal places for the currency used by this piggy bank. This will always be the piggy bank's currency, never the primary currency.
     */
    currency_decimal_places?: number;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type AutocompleteRecurrence = {
    id: string;
    /**
     * Name of the recurrence found by an auto-complete search.
     */
    name: string;
    /**
     * Description of the recurrence found by auto-complete.
     */
    description?: string;
    /**
     * Is the recurring transaction active or not?
     */
    active?: boolean;
};

export type AutocompleteRule = {
    id: string;
    /**
     * Name of the rule found by an auto-complete search.
     */
    name: string;
    /**
     * Description of the rule found by auto-complete.
     */
    description?: string;
    /**
     * Is the bill active or not?
     */
    active?: boolean;
};

export type AutocompleteRuleGroup = {
    id: string;
    /**
     * Name of the rule group found by an auto-complete search.
     */
    name: string;
    /**
     * Description of the rule group found by auto-complete.
     */
    description?: string;
    /**
     * Is the bill active or not?
     */
    active?: boolean;
};

export type AutocompleteTag = {
    id: string;
    /**
     * Name of the tag found by an auto-complete search.
     */
    name: string;
    /**
     * Name of the tag found by an auto-complete search.
     */
    tag: string;
};

export type AutocompleteTransaction = {
    /**
     * The ID of a transaction journal (basically a single split).
     */
    id: string;
    /**
     * The ID of the underlying transaction group.
     */
    transaction_group_id?: string;
    /**
     * Transaction description
     */
    name: string;
    /**
     * Transaction description
     */
    description: string;
};

export type AutocompleteTransactionId = {
    /**
     * The ID of a transaction journal (basically a single split).
     */
    id: string;
    /**
     * The ID of the underlying transaction group.
     */
    transaction_group_id?: string;
    /**
     * Transaction description with ID in the name.
     */
    name: string;
    /**
     * Transaction description with ID in the name.
     */
    description: string;
};

export type AutocompleteTransactionType = {
    id: string;
    /**
     * Type of the object found by an auto-complete search.
     */
    name: string;
    /**
     * Name of the object found by an auto-complete search.
     */
    type: string;
};

export type ChartDataPoint = {
    /**
     * The key is the label of the value, so for example: '2018-01-01' => 13 or 'Groceries' => -123.
     */
    key?: string;
};

export type ChartDataSet = {
    /**
     * This is the title of the current set. It can refer to an account, a budget or another object (by name).
     */
    label?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    date?: string;
    start_date?: string;
    end_date?: string;
    /**
     * Indicated the type of chart that is expected to be rendered. You can safely ignore this if you want.
     */
    type?: string;
    period?: ChartDatasetPeriodProperty;
    /**
     * Used to indicate the Y axis for this data set. Is usually between 0 and 1 (left and right side of the chart).
     */
    yAxisID?: number;
    /**
     * The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value.
     */
    entries?: {
        [key: string]: unknown;
    };
    /**
     * The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value.
     */
    pc_entries?: {
        [key: string]: unknown;
    };
};

export type ChartLine = Array<ChartDataSet>;

export type DataDestroyObject = 'not_assets_liabilities' | 'budgets' | 'bills' | 'piggy_banks' | 'rules' | 'recurring' | 'categories' | 'tags' | 'object_groups' | 'accounts' | 'asset_accounts' | 'expense_accounts' | 'revenue_accounts' | 'liabilities' | 'transactions' | 'withdrawals' | 'deposits' | 'transfers';

export type AccountSearchFieldFilter = 'all' | 'iban' | 'name' | 'number' | 'id';

/**
 * Title of the configuration value.
 */
export type ConfigValueFilter = 'configuration.is_demo_site' | 'configuration.permission_update_check' | 'configuration.last_update_check' | 'configuration.single_user_mode' | 'firefly.version' | 'firefly.default_location' | 'firefly.account_to_transaction' | 'firefly.allowed_opposing_types' | 'firefly.accountRoles' | 'firefly.valid_liabilities' | 'firefly.interest_periods' | 'firefly.enable_external_map' | 'firefly.expected_source_types' | 'app.timezone' | 'firefly.bill_periods' | 'firefly.credit_card_types' | 'firefly.languages' | 'firefly.valid_view_ranges' | 'cer.enabled' | 'firefly.preselected_accounts' | 'firefly.rule-actions' | 'firefly.context-rule-actions' | 'search.operators' | 'webhook.triggers' | 'webhook.responses' | 'webhook.deliveries';

export type ConfigValueUpdateFilter = 'configuration.is_demo_site' | 'configuration.permission_update_check' | 'configuration.last_update_check' | 'configuration.single_user_mode';

export type ExportFileFilter = 'csv';

export type InsightGroup = Array<InsightGroupEntry>;

export type InsightGroupEntry = {
    /**
     * This ID is a reference to the original object.
     */
    id?: string;
    /**
     * This is the name of the object.
     */
    name?: string;
    /**
     * The amount spent or earned between start date and end date, a number defined as a string, for this object and all asset accounts.
     */
    difference?: string;
    /**
     * The amount spent or earned between start date and end date, a number as a float, for this object and all asset accounts. May have rounding errors.
     */
    difference_float?: number;
    /**
     * The currency ID of the expenses listed for this account.
     */
    currency_id?: string;
    /**
     * The currency code of the expenses listed for this account.
     */
    currency_code?: string;
};

export type InsightTotal = Array<InsightTotalEntry>;

export type InsightTotalEntry = {
    /**
     * The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts.
     */
    difference?: string;
    /**
     * The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts. This number is a float (double) and may have rounding errors.
     */
    difference_float?: number;
    /**
     * The currency ID of the expenses listed for this expense account.
     */
    currency_id?: string;
    /**
     * The currency code of the expenses listed for this expense account.
     */
    currency_code?: string;
};

export type InsightTransfer = Array<InsightTransferEntry>;

export type InsightTransferEntry = {
    /**
     * This ID is a reference to the original object.
     */
    id?: string;
    /**
     * This is the name of the object.
     */
    name?: string;
    /**
     * The total amount transferred between start date and end date, a number defined as a string, for this asset account.
     */
    difference?: string;
    /**
     * The total amount transferred between start date and end date, a number as a float, for this asset account. May have rounding errors.
     */
    difference_float?: number;
    /**
     * The total amount transferred TO this account between start date and end date, a number defined as a string, for this asset account.
     */
    in?: string;
    /**
     * The total amount transferred FROM this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
     */
    in_float?: number;
    /**
     * The total amount transferred FROM this account between start date and end date, a number defined as a string, for this asset account.
     */
    out?: string;
    /**
     * The total amount transferred TO this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
     */
    out_float?: number;
    /**
     * The currency ID of the expenses listed for this account.
     */
    currency_id?: string;
    /**
     * The currency code of the expenses listed for this account.
     */
    currency_code?: string;
};

export type CategoryRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: CategoryProperties;
};

export type CategorySingle = {
    data: CategoryRead;
};

export type ConfigurationSingle = {
    data: Configuration;
};

export type CurrencyRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: CurrencyProperties;
};

export type CurrencySingle = {
    data: CurrencyRead;
};

export type LinkTypeRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: LinkType;
    links: ObjectLink;
};

export type LinkTypeSingle = {
    data: LinkTypeRead;
};

export type ObjectGroupRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: ObjectGroup;
};

export type ObjectGroupSingle = {
    data: ObjectGroupRead;
};

export type PiggyBankEventRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: PiggyBankEventProperties;
    links: ObjectLink;
};

export type PiggyBankRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: PiggyBankProperties;
    links: ObjectLink;
};

export type PiggyBankSingle = {
    data: PiggyBankRead;
};

export type PreferenceRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: Preference;
};

export type PreferenceSingle = {
    data: PreferenceRead;
};

export type RecurrenceRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: RecurrenceProperties;
    links: ObjectLink;
};

export type RecurrenceSingle = {
    data: RecurrenceRead;
};

export type RuleGroupRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: RuleGroup;
    links: ObjectLink;
};

export type RuleGroupSingle = {
    data: RuleGroupRead;
};

export type RuleRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: Rule;
    links: ObjectLink;
};

export type RuleSingle = {
    data: RuleRead;
};

export type TagRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: TagModel;
    links: ObjectLink;
};

export type TagSingle = {
    data: TagRead;
};

export type TransactionLinkRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: TransactionLink;
    links: ObjectLink;
};

export type TransactionLinkSingle = {
    data: TransactionLinkRead;
};

export type TransactionRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: Transaction;
    links: ObjectLink;
};

export type TransactionSingle = {
    data: TransactionRead;
};

export type UserRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: User;
    links: ObjectLink;
};

export type WebhookAttemptRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookAttempt;
};

export type WebhookAttemptSingle = {
    data: WebhookAttemptRead;
};

export type WebhookMessageRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookMessage;
};

export type WebhookMessageSingle = {
    data: WebhookMessageRead;
};

export type WebhookRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookProperties;
    links: ObjectLink;
};

export type WebhookSingle = {
    data: WebhookRead;
};

export type AccountProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    active?: boolean;
    /**
     * Order of the account. Is NULL if account is not asset or liability.
     */
    order?: number | null;
    name: string;
    type: ShortAccountTypeProperty;
    account_role?: AccountRoleProperty;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     */
    readonly object_group_order?: number | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    /**
     * Indicates whether the account has a currency setting. If false, the account uses the administration's primary currency. Asset accounts and liability accounts always have a currency setting, while expense and revenue accounts do not.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * The current balance of the account in the account's currency. If the account has no currency, this is the balance in the administration's primary currency. Either way, the `currency_*` fields reflect the currency used.
     */
    readonly current_balance?: string;
    /**
     * The current balance of the account in the administration's primary currency. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    readonly pc_current_balance?: string | null;
    /**
     * If you submit a start AND end date, this will be the difference between those two moments.
     */
    readonly balance_difference?: string;
    /**
     * If you submit a start AND end date, this will be the difference in the currency of the account or the administration's primary currency between those two moments.
     */
    readonly pc_balance_difference?: string | null;
    /**
     * Represents the opening balance, the initial amount this account holds in the currency of the account or the administration's primary currency if the account has no currency. Either way, the `currency_*` fields reflect the currency used.
     */
    opening_balance?: string;
    /**
     * The opening balance of the account in the administration's primary currency (pc). The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_opening_balance?: string;
    /**
     * The virtual balance of the account in the account's currency or the administration's primary currency if the account has no currency.
     */
    virtual_balance?: string;
    /**
     * The virtual balance of the account in the administration's primary currency (pc). The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_virtual_balance?: string;
    /**
     * In liability accounts (loans, debts and mortgages), this is the amount of debt in the account's currency (see the `currency_*` fields). In asset accounts, this is NULL.
     */
    debt_amount?: string | null;
    /**
     * In liability accounts (loans, debts and mortgages), this is the amount of debt in the administration's primary currency (see the `currency_*` fields. In asset accounts, this is NULL.
     */
    pc_debt_amount?: string | null;
    /**
     * The timestamp for this date is always 23:59:59, to indicate it's the balance at the very END of that particular day.
     */
    readonly current_balance_date?: string;
    notes?: string | null;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     */
    monthly_payment_date?: string | null;
    credit_card_type?: CreditCardTypeProperty;
    account_number?: string | null;
    iban?: string | null;
    bic?: string | null;
    /**
     * Represents the date of the opening balance.
     */
    opening_balance_date?: string | null;
    liability_type?: LiabilityTypeProperty;
    liability_direction?: LiabilityDirectionProperty;
    /**
     * Mandatory when type is liability. Interest percentage.
     */
    interest?: string | null;
    interest_period?: InterestPeriodProperty;
    include_net_worth?: boolean;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
    /**
     * Last activity of the account.
     */
    last_activity?: string | null;
};

export type AccountRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AccountProperties;
};

export type AccountSingle = {
    data: AccountRead;
};

export type AccountStore = {
    name: string;
    type: ShortAccountTypeProperty;
    iban?: string | null;
    bic?: string | null;
    account_number?: string | null;
    /**
     * Represents the opening balance, the initial amount this account holds.
     */
    opening_balance?: string;
    /**
     * Represents the date of the opening balance.
     */
    opening_balance_date?: string | null;
    virtual_balance?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    currency_code?: string;
    /**
     * If omitted, defaults to true.
     */
    active?: boolean;
    /**
     * Order of the account
     */
    order?: number;
    /**
     * If omitted, defaults to true.
     */
    include_net_worth?: boolean;
    account_role?: AccountRoleProperty;
    credit_card_type?: CreditCardTypeProperty;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     */
    monthly_payment_date?: string | null;
    liability_type?: LiabilityTypeProperty;
    liability_direction?: LiabilityDirectionProperty;
    /**
     * Mandatory when type is liability. Interest percentage.
     */
    interest?: string | null;
    interest_period?: InterestPeriodProperty;
    notes?: string | null;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
};

export type AccountUpdate = {
    name: string;
    iban?: string | null;
    bic?: string | null;
    account_number?: string | null;
    opening_balance?: string;
    opening_balance_date?: string | null;
    virtual_balance?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    currency_code?: string;
    /**
     * If omitted, defaults to true.
     */
    active?: boolean;
    /**
     * Order of the account
     */
    order?: number;
    /**
     * If omitted, defaults to true.
     */
    include_net_worth?: boolean;
    account_role?: AccountRoleProperty;
    credit_card_type?: CreditCardTypeProperty;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     */
    monthly_payment_date?: string | null;
    liability_type?: LiabilityTypeProperty;
    /**
     * Mandatory when type is liability. Interest percentage.
     */
    interest?: string | null;
    interest_period?: InterestPeriodProperty;
    notes?: string | null;
    /**
     * Latitude of the account's location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     */
    latitude?: number | null;
    /**
     * Latitude of the account's location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     */
    zoom_level?: number | null;
};

export type ArrayEntryWithCurrencyAndSum = {
    currency_id?: string;
    currency_code?: string;
    currency_symbol?: string;
    /**
     * Number of decimals supported by the currency
     */
    currency_decimal_places?: number;
    /**
     * The amount earned, spent or transferred.
     */
    sum?: string;
};

export type AttachmentProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    attachable_type?: AttachableType;
    /**
     * ID of the model this attachment is linked to.
     */
    attachable_id?: string;
    /**
     * Hash of the file for basic duplicate detection.
     */
    hash?: string;
    filename?: string;
    download_url?: string;
    upload_url?: string;
    title?: string | null;
    notes?: string | null;
    readonly mime?: string;
    readonly size?: number;
};

export type AttachmentRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AttachmentProperties;
    links: ObjectLink;
};

export type AttachmentSingle = {
    data: AttachmentRead;
};

export type AttachmentStore = {
    filename: string;
    attachable_type: AttachableType;
    /**
     * ID of the model this attachment is linked to.
     */
    attachable_id: string;
    title?: string;
    notes?: string | null;
};

export type AttachmentUpdate = {
    filename?: string;
    title?: string;
    notes?: string | null;
};

export type AvailableBudgetProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * The amount of this available budget in the currency of this available budget.
     */
    amount?: string;
    /**
     * The amount of this available budget in the primary currency (pc) of this administration.
     */
    pc_amount?: string;
    /**
     * Start date of the available budget.
     */
    start?: string;
    /**
     * End date of the available budget.
     */
    end?: string;
    readonly spent_in_budgets?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * The amount spent in budgets in the primary currency (pc) of this administration.
     *
     */
    readonly pc_spent_in_budgets?: Array<ArrayEntryWithCurrencyAndSum>;
    readonly spent_outside_budgets?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * The amount spent outside of budgets in the primary currency (pc) of this administration.
     *
     */
    readonly pc_spent_outside_budgets?: Array<ArrayEntryWithCurrencyAndSum>;
};

export type AvailableBudgetRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AvailableBudgetProperties;
};

export type AvailableBudgetSingle = {
    data: AvailableBudgetRead;
};

export type BillProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * The name of the subscription.
     */
    name?: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * The minimum amount that is expected for this subscription in the subscription's currency.
     */
    amount_min?: string;
    /**
     * The minimum amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_min?: string;
    /**
     * The maximum amount that is expected for this subscription in the subscription's currency.
     */
    amount_max?: string;
    /**
     * The maximum amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_max?: string;
    /**
     * The average amount that is expected for this subscription in the subscription's currency.
     */
    amount_avg?: string;
    /**
     * The average amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_avg?: string;
    date?: string;
    /**
     * The date after which this subscription is no longer valid or applicable
     */
    end_date?: string | null;
    /**
     * The date before which the subscription must be renewed (or cancelled)
     */
    extension_date?: string | null;
    repeat_freq?: BillRepeatFrequency;
    /**
     * How often the subscription will be skipped. 1 means a bi-monthly subscription.
     */
    skip?: number;
    /**
     * If the subscription is active.
     */
    active?: boolean;
    /**
     * Order of the subscription.
     */
    order?: number;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     */
    readonly object_group_order?: number | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    /**
     * Array of past transactions when the subscription was paid.
     */
    readonly paid_dates?: Array<{
        /**
         * Transaction group ID of the transaction linked to this subscription.
         */
        readonly transaction_group_id?: string;
        /**
         * Transaction journal ID of the transaction linked to this subscription.
         */
        readonly transaction_journal_id?: string;
        /**
         * Date the bill was paid.
         */
        readonly date?: string;
        /**
         * ID of this subscription.
         */
        readonly subscription_id?: string;
        /**
         * The currency ID of the currency associated with this object.
         */
        currency_id?: string;
        /**
         * The currency name of the currency associated with this object.
         */
        currency_name?: string;
        /**
         * The currency code of the currency associated with this object.
         */
        currency_code?: string;
        readonly currency_symbol?: string;
        readonly currency_decimal_places?: number;
        /**
         * The currency ID of the administration's primary currency.
         */
        readonly primary_currency_id?: string;
        /**
         * The currency name of the administration's primary currency.
         */
        readonly primary_currency_name?: string;
        /**
         * The currency code of the administration's primary currency.
         */
        readonly primary_currency_code?: string;
        /**
         * The currency symbol of the administration's primary currency.
         */
        readonly primary_currency_symbol?: string;
        /**
         * The currency decimal places of the administration's primary currency.
         */
        readonly primary_currency_decimal_places?: number;
        /**
         * The amount that was paid for this subscription in the subscription's currency.
         */
        amount?: string;
        /**
         * The amount that was paid for this subscription in the administration's primary currency.
         */
        pc_amount?: string;
        /**
         * The foreign amount that was paid for this subscription in the subscription's currency.
         */
        foreign_amount?: string;
        /**
         * The foreign amount that was paid for this subscription in the administration's primary currency.
         */
        pc_foreign_amount?: string;
    }>;
    /**
     * Array of future dates when the bill is expected to be paid. Autogenerated.
     */
    readonly pay_dates?: Array<string>;
    /**
     * When the subscription is expected to be due.
     */
    readonly next_expected_match?: string | null;
    /**
     * Formatted (locally) when the subscription is due.
     */
    readonly next_expected_match_diff?: string | null;
};

export type BillRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BillProperties;
};

export type BillSingle = {
    data: BillRead;
};

export type BillStore = {
    /**
     * Use either currency_id or currency_code
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code
     */
    currency_code?: string;
    name: string;
    amount_min: string;
    amount_max: string;
    date: string;
    /**
     * The date after which this bill is no longer valid or applicable
     */
    end_date?: string;
    /**
     * The date before which the bill must be renewed (or cancelled)
     */
    extension_date?: string;
    repeat_freq: BillRepeatFrequency;
    /**
     * How often the bill must be skipped. 1 means a bi-monthly bill.
     */
    skip?: number;
    /**
     * If the bill is active.
     */
    active?: boolean;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type BillUpdate = {
    /**
     * Use either currency_id or currency_code
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code
     */
    currency_code?: string;
    name: string;
    amount_min?: string;
    amount_max?: string;
    date?: string;
    /**
     * The date after which this bill is no longer valid or applicable
     */
    end_date?: string;
    /**
     * The date before which the bill must be renewed (or cancelled)
     */
    extension_date?: string;
    repeat_freq?: BillRepeatFrequency;
    /**
     * How often the bill must be skipped. 1 means a bi-monthly bill.
     */
    skip?: number;
    /**
     * If the bill is active.
     */
    active?: boolean;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type BudgetProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    active?: boolean;
    name: string;
    readonly order?: number;
    notes?: string | null;
    auto_budget_type?: AutoBudgetType;
    auto_budget_period?: AutoBudgetPeriod;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     */
    readonly object_group_order?: number | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * The amount for the auto-budget, if set.
     */
    auto_budget_amount?: string | null;
    /**
     * The amount for the auto-budget, if set in the primary currency of the administration.
     */
    pc_auto_budget_amount?: string | null;
    /**
     * Information on how much was spent in this budget. Is only filled in when the start and end date are submitted.
     */
    readonly spent?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Information on how much was spent in this budget. Is only filled in when the start and end date are submitted. It is converted to the primary currency of the administration.
     */
    readonly pc_spent?: Array<ArrayEntryWithCurrencyAndSum>;
};

export type BudgetRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BudgetProperties;
};

export type BudgetSingle = {
    data: BudgetRead;
};

export type BudgetStore = {
    name: string;
    active?: boolean;
    readonly order?: number;
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    auto_budget_type?: AutoBudgetType;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_id?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_code?: string | null;
    auto_budget_amount?: string | null;
    auto_budget_period?: AutoBudgetPeriod;
};

export type BudgetUpdate = {
    name: string;
    active?: boolean;
    order?: number;
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    auto_budget_type?: AutoBudgetType;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_id?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_code?: string | null;
    auto_budget_amount?: string | null;
    auto_budget_period?: AutoBudgetPeriod;
};

export type BudgetLimitProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Start date of the budget limit.
     */
    start?: string;
    /**
     * End date of the budget limit.
     */
    end?: string;
    /**
     * The budget ID of the associated budget.
     */
    readonly budget_id?: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    amount?: string;
    /**
     * The amount of this budget limit in the user's primary currency, if the original amount is in a different currency.
     */
    readonly pc_amount?: string | null;
    /**
     * Period of the budget limit. Only used when auto-generated by auto-budget.
     */
    readonly period?: string | null;
    /**
     * Amount(s) spent in the currencies in the database for this budget limit.
     */
    readonly spent?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) spent in the primary currency in the database for this budget limit.
     */
    readonly pc_spent?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
};

export type BudgetLimitRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BudgetLimitProperties;
};

export type BudgetLimitSingle = {
    data: BudgetLimitRead;
};

export type BudgetLimitStore = {
    /**
     * Use either currency_id or currency_code. Defaults to the user's primary currency.
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's primary currency.
     */
    currency_code?: string;
    /**
     * The budget ID of the associated budget.
     */
    readonly budget_id: string;
    /**
     * Start date of the budget limit.
     */
    start: string;
    /**
     * Period of the budget limit. Only used when auto-generated by auto-budget.
     */
    readonly period?: string | null;
    /**
     * End date of the budget limit.
     */
    end: string;
    amount: string;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
};

export type BudgetLimitUpdate = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Start date of the budget limit.
     */
    start?: string;
    /**
     * End date of the budget limit.
     */
    end?: string;
    /**
     * The budget ID of the associated budget.
     */
    readonly budget_id?: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * Period of the budget limit. Only used when auto-generated by auto-budget.
     */
    readonly period?: string | null;
    amount?: string;
    /**
     * The amount of this budget limit in the user's primary currency, if the original amount is in a different currency.
     */
    readonly pc_amount?: string | null;
    /**
     * Will be in the primary currency if this is turned on by the user.
     */
    readonly spent?: string | null;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
};

export type CategoryProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    name: string;
    notes?: string | null;
    /**
     * This object never has its own currency setting, so this value is always false.
     */
    object_has_currency_setting?: boolean;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * Amount(s) spent in the currencies in the database for this category. ONLY present when start and date are set.
     */
    readonly spent?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) spent in the primary currency in the database for this category. ONLY present when start and date are set.
     */
    readonly pc_spent?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) earned in the currencies in the database for this category. ONLY present when start and date are set.
     */
    readonly earned?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) earned in the primary currency in the database for this category. ONLY present when start and date are set.
     */
    readonly pc_earned?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) transferred in the currencies in the database for this category. ONLY present when start and date are set.
     */
    readonly transferred?: Array<ArrayEntryWithCurrencyAndSum>;
    /**
     * Amount(s) transferred in primary currency in the database for this category. ONLY present when start and date are set.
     */
    readonly pc_transferred?: Array<ArrayEntryWithCurrencyAndSum>;
};

export type CategoryStore = {
    name: string;
    notes?: string | null;
};

export type CategoryUpdate = {
    name: string;
    notes?: string | null;
};

export type CurrencyExchangeProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Base currency ID for this exchange rate entry.
     */
    readonly from_currency_id?: string;
    /**
     * Base currency name for this exchange rate entry.
     */
    readonly from_currency_name?: string;
    /**
     * Base currency code for this exchange rate entry.
     */
    readonly from_currency_code?: string;
    /**
     * Base currency symbol for this exchange rate entry.
     */
    readonly from_currency_symbol?: string;
    /**
     * Base currency decimal places for this exchange rate entry.
     */
    readonly from_currency_decimal_places?: number;
    /**
     * Destination currency ID for this exchange rate entry.
     */
    readonly to_currency_id?: string;
    /**
     * Destination currency name for this exchange rate entry.
     */
    readonly to_currency_name?: string;
    /**
     * Destination currency code for this exchange rate entry.
     */
    readonly to_currency_code?: string;
    /**
     * Destination currency symbol for this exchange rate entry.
     */
    readonly to_currency_symbol?: string;
    /**
     * Destination currency decimal places for this exchange rate entry.
     */
    readonly to_currency_decimal_places?: number;
    /**
     * The actual exchange rate. How many 'to' currency will you get for 1 'from' currency?
     */
    readonly rate?: string;
    /**
     * Date and time of the exchange rate.
     */
    readonly date?: string;
};

export type CurrencyExchangeRateRead = {
    /**
     * Immutable value
     */
    readonly type?: string;
    readonly id?: string;
    attributes?: CurrencyExchangeProperties;
    links?: ObjectLink;
};

export type CurrencyExchangeRateSingle = {
    data: CurrencyExchangeRateRead;
};

export type CurrencyExchangeRateStore = {
    /**
     * The date to which the exchange rate is applicable.
     */
    date: string;
    /**
     * The base currency code.
     */
    from: string;
    /**
     * The destination currency code.
     */
    to: string;
    /**
     * The exchange rate from the base currency to the destination currency.
     */
    rate?: string;
};

export type CurrencyExchangeRateStoreByDate = {
    /**
     * The 'from'-currency
     */
    from: string;
    /**
     * The actual entries for this data set. They 'key' value is 'to' currency. The value is the exchange rate.
     */
    rates: {
        [key: string]: string;
    };
};

/**
 * The actual entries for this data set. They 'key' value is the date in YYYY-MM-DD. The value is the exchange rate.
 */
export type CurrencyExchangeRateStoreByPair = {
    [key: string]: string;
};

export type CurrencyExchangeRateUpdate = {
    /**
     * The date to which the exchange rate is applicable.
     */
    date: string;
    /**
     * The exchange rate from the base currency to the destination currency.
     */
    rate: string;
    /**
     * The base currency code.
     */
    from?: string | null;
    /**
     * The destination currency code.
     */
    to?: string | null;
};

export type CurrencyExchangeRateUpdateNoDate = {
    /**
     * The exchange rate from the base currency to the destination currency.
     */
    rate: string;
};

export type ObjectGroup = {
    readonly created_at?: string;
    readonly updated_at?: string;
    title: string;
    /**
     * Order of the object group
     */
    order: number;
};

export type ObjectGroupUpdate = {
    title: string;
    /**
     * Order of the object group
     */
    order?: number;
};

export type ObjectLink = {
    0?: {
        rel?: string;
        uri?: string;
    };
    self?: string;
};

export type PageLink = {
    self?: string;
    first?: string;
    next?: string | null;
    prev?: string | null;
    last?: string;
};

export type PiggyBankAccountRead = {
    /**
     * The ID of the account.
     */
    readonly account_id?: string;
    readonly name?: string;
    current_amount?: string;
    /**
     * If convertToPrimary is on, this will show the amount in the primary currency.
     */
    pc_current_amount?: string;
};

export type PiggyBankAccountStore = {
    /**
     * The ID of the account.
     */
    id: string | null;
    /**
     * The name of the account.
     */
    name?: string | null;
    /**
     * The amount saved currently.
     */
    current_amount?: string;
};

export type PiggyBankAccountUpdate = {
    /**
     * The ID of the account.
     */
    account_id?: string | null;
    /**
     * The name of the account.
     */
    name?: string | null;
    /**
     * The amount saved currently.
     */
    current_amount?: string | null;
};

export type PiggyBankProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    name: string;
    /**
     * The percentage of the target amount that has been saved, if a target amount is set.
     */
    readonly percentage?: number | null;
    /**
     * The date you started with this piggy bank.
     */
    start_date?: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    readonly active?: boolean;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     */
    readonly object_group_order?: number | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    accounts?: Array<PiggyBankAccountRead>;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    target_amount: string | null;
    /**
     * The target amount in the primary currency of the administration.
     */
    pc_target_amount?: string | null;
    current_amount?: string;
    /**
     * The current amount in the primary currency of the administration.
     */
    pc_current_amount?: string;
    left_to_save?: string | null;
    pc_left_to_save?: string | null;
    readonly save_per_month?: string | null;
    readonly pc_save_per_month?: string | null;
};

export type PiggyBankStore = {
    name: string;
    accounts?: Array<PiggyBankAccountStore>;
    target_amount: string | null;
    current_amount?: string;
    /**
     * The date you started with this piggy bank.
     */
    start_date: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    readonly active?: boolean;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type PiggyBankUpdate = {
    name?: string;
    accounts?: Array<PiggyBankAccountUpdate>;
    readonly currency_id?: string;
    readonly currency_code?: string;
    target_amount?: string | null;
    /**
     * The date you started with this piggy bank.
     */
    start_date?: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    readonly active?: boolean;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type PiggyBankEventProperties = {
    created_at?: string;
    updated_at?: string;
    amount?: string;
    pc_amount?: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * The journal associated with the event.
     */
    transaction_journal_id?: string | null;
    /**
     * The transaction group associated with the event.
     */
    transaction_group_id?: string | null;
};

export type Preference = {
    readonly created_at?: string;
    readonly updated_at?: string;
    name: string;
    data: PolymorphicProperty;
};

export type PreferenceUpdate = {
    data: PolymorphicProperty;
};

export type RecurrenceProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    type?: RecurrenceTransactionType;
    title?: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     */
    description?: string;
    /**
     * First time the recurring transaction will fire. Must be after today.
     */
    first_date?: string;
    /**
     * Last time the recurring transaction has fired.
     */
    readonly latest_date?: string | null;
    /**
     * Date until the recurring transaction can fire. Use either this field or repetitions.
     */
    repeat_until?: string | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     */
    apply_rules?: boolean;
    /**
     * If the recurrence is even active.
     */
    active?: boolean;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     */
    nr_of_repetitions?: number | null;
    notes?: string | null;
    repetitions?: Array<RecurrenceRepetition>;
    transactions?: Array<RecurrenceTransaction>;
};

export type RecurrenceStore = {
    type: RecurrenceTransactionType;
    title: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     */
    description?: string;
    /**
     * First time the recurring transaction will fire. Must be after today.
     */
    first_date: string;
    /**
     * Date until the recurring transaction can fire. Use either this field or repetitions.
     */
    repeat_until: string | null;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     */
    nr_of_repetitions?: number | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     */
    apply_rules?: boolean;
    /**
     * If the recurrence is even active.
     */
    active?: boolean;
    notes?: string | null;
    repetitions: Array<RecurrenceRepetitionStore>;
    transactions: Array<RecurrenceTransactionStore>;
};

export type RecurrenceUpdate = {
    title?: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     */
    description?: string;
    /**
     * First time the recurring transaction will fire.
     */
    first_date?: string;
    /**
     * Date until when the recurring transaction can fire. After that date, it's basically inactive. Use either this field or repetitions.
     */
    repeat_until?: string | null;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     */
    nr_of_repetitions?: number | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     */
    apply_rules?: boolean;
    /**
     * If the recurrence is even active.
     */
    active?: boolean;
    notes?: string | null;
    repetitions?: Array<RecurrenceRepetitionUpdate>;
    transactions?: Array<RecurrenceTransactionUpdate>;
};

export type RecurrenceRepetition = {
    readonly id?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    type: RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition.
     * - For 'daily', this is empty.
     * - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
     * - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
     * - For 'monthly' it is the day of the month (1 - 31)
     * - For yearly, it is a full date, ie '2025-11-01'. The year you use does not matter.
     *
     */
    moment: string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     */
    skip?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values:
     * 1. Do nothing, just create it
     * 2. Create no transaction.
     * 3. Skip to the previous Friday.
     * 4. Skip to the next Monday.
     *
     */
    weekend?: number;
    /**
     * Auto-generated repetition description.
     */
    readonly description?: string;
    /**
     * Array of future dates when the repetition will apply to. Auto generated.
     */
    readonly occurrences?: Array<string>;
};

export type RecurrenceRepetitionStore = {
    type: RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition.
     * - For 'daily', this is empty.
     * - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
     * - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
     * - For 'monthly' it is the day of the month (1 - 31)
     * - For yearly, it is a full date, ie '2025-11-01'. The year you use does not matter.
     *
     */
    moment: string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     */
    skip?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values:
     * 1. Do nothing, just create it
     * 2. Create no transaction.
     * 3. Skip to the previous Friday.
     * 4. Skip to the next Monday.
     *
     */
    weekend?: number;
};

export type RecurrenceRepetitionUpdate = {
    type?: RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition.
     * - For 'daily', this is empty.
     * - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
     * - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
     * - For 'monthly' it is the day of the month (1 - 31)
     * - For yearly, it is a full date, ie '2025-11-01'. The year you use does not matter.
     *
     */
    moment?: string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     */
    skip?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values:
     * 1. Do nothing, just create it
     * 2. Create no transaction.
     * 3. Skip to the previous Friday.
     * 4. Skip to the next Monday.
     *
     */
    weekend?: number;
};

export type RecurrenceTransaction = {
    id?: string;
    description: string;
    /**
     * Indicates whether the object has a currency setting. If false, the object uses the administration's primary currency.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    readonly currency_symbol?: string;
    readonly currency_decimal_places?: number;
    /**
     * The currency ID of the administration's primary currency.
     */
    readonly primary_currency_id?: string;
    /**
     * The currency name of the administration's primary currency.
     */
    readonly primary_currency_name?: string;
    /**
     * The currency code of the administration's primary currency.
     */
    readonly primary_currency_code?: string;
    /**
     * The currency symbol of the administration's primary currency.
     */
    readonly primary_currency_symbol?: string;
    /**
     * The currency decimal places of the administration's primary currency.
     */
    readonly primary_currency_decimal_places?: number;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Amount of the transaction in primary currency.
     */
    pc_amount?: string;
    /**
     * Foreign amount of the transaction.
     */
    foreign_amount?: string | null;
    /**
     * Foreign amount of the transaction.
     */
    pc_foreign_amount?: string | null;
    foreign_currency_id?: string | null;
    foreign_currency_name?: string | null;
    foreign_currency_code?: string | null;
    readonly foreign_currency_symbol?: string | null;
    /**
     * Number of decimals in the currency
     */
    readonly foreign_currency_decimal_places?: number | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     */
    readonly budget_name?: string | null;
    /**
     * Category ID for this transaction.
     */
    category_id?: string;
    /**
     * Category name for this transaction.
     */
    category_name?: string;
    /**
     * ID of the source account. Submit either this or source_name.
     */
    source_id?: string;
    /**
     * Name of the source account. Submit either this or source_id.
     */
    source_name?: string;
    readonly source_iban?: string | null;
    source_type?: AccountTypeProperty;
    /**
     * ID of the destination account. Submit either this or destination_name.
     */
    destination_id?: string;
    /**
     * Name of the destination account. Submit either this or destination_id.
     */
    destination_name?: string;
    readonly destination_iban?: string | null;
    destination_type?: AccountTypeProperty;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    piggy_bank_id?: string | null;
    piggy_bank_name?: string | null;
    subscription_id?: string | null;
    subscription_name?: string | null;
};

export type RecurrenceTransactionStore = {
    description: string;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Foreign amount of the transaction.
     */
    foreign_amount?: string | null;
    /**
     * Submit either a currency_id or a currency_code.
     */
    currency_id?: string;
    /**
     * Submit either a currency_id or a currency_code.
     */
    currency_code?: string;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     */
    foreign_currency_id?: string | null;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     */
    foreign_currency_code?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string;
    /**
     * Category ID for this transaction.
     */
    category_id?: string;
    /**
     * ID of the source account.
     */
    source_id: string;
    /**
     * ID of the destination account.
     */
    destination_id: string;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    /**
     * Optional.
     */
    piggy_bank_id?: string | null;
    /**
     * Optional.
     */
    bill_id?: string | null;
};

export type RecurrenceTransactionUpdate = {
    id: string;
    description?: string;
    /**
     * Amount of the transaction.
     */
    amount?: string;
    /**
     * Foreign amount of the transaction.
     */
    foreign_amount?: string | null;
    /**
     * Submit either a currency_id or a currency_code.
     */
    currency_id?: string;
    /**
     * Submit either a currency_id or a currency_code.
     */
    currency_code?: string;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     */
    foreign_currency_id?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string;
    /**
     * Category ID for this transaction.
     */
    category_id?: string;
    /**
     * ID of the source account. Submit either this or source_name.
     */
    source_id?: string;
    /**
     * ID of the destination account. Submit either this or destination_name.
     */
    destination_id?: string;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    piggy_bank_id?: string | null;
    /**
     * Optional.
     */
    bill_id?: string | null;
};

export type Rule = {
    readonly created_at?: string;
    readonly updated_at?: string;
    title: string;
    description?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     */
    rule_group_id: string;
    /**
     * Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
     */
    rule_group_title?: string;
    readonly order?: number;
    trigger: RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     */
    active?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     */
    strict?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     */
    stop_processing?: boolean;
    triggers: Array<RuleTrigger>;
    actions: Array<RuleAction>;
};

export type RuleStore = {
    title: string;
    description?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     */
    rule_group_id: string;
    /**
     * Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
     */
    rule_group_title?: string;
    order?: number;
    trigger: RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     */
    active?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     */
    strict?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     */
    stop_processing?: boolean;
    triggers: Array<RuleTriggerStore>;
    actions: Array<RuleActionStore>;
};

export type RuleUpdate = {
    title?: string;
    description?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     */
    rule_group_id?: string;
    order?: number;
    trigger?: RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     */
    active?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     */
    strict?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     */
    stop_processing?: boolean;
    triggers?: Array<RuleTriggerUpdate>;
    actions?: Array<RuleActionUpdate>;
};

export type RuleAction = {
    readonly id?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    type: RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     */
    value: string | null;
    /**
     * Order of the action
     */
    order?: number;
    /**
     * If the action is active. Defaults to true.
     */
    active?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired. Defaults to false.
     */
    stop_processing?: boolean;
};

export type RuleActionStore = {
    type: RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     */
    value: string | null;
    /**
     * Order of the action
     */
    order?: number;
    /**
     * If the action is active. Defaults to true.
     */
    active?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired. Defaults to false.
     */
    stop_processing?: boolean;
};

export type RuleActionUpdate = {
    type?: RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     */
    value?: string | null;
    /**
     * Order of the action
     */
    order?: number;
    /**
     * If the action is active.
     */
    active?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired.
     */
    stop_processing?: boolean;
};

export type RuleGroup = {
    readonly created_at?: string;
    readonly updated_at?: string;
    title: string;
    description?: string | null;
    readonly order?: number;
    active?: boolean;
};

export type RuleGroupStore = {
    title: string;
    description?: string | null;
    order?: number;
    active?: boolean;
};

export type RuleGroupUpdate = {
    title?: string;
    description?: string | null;
    order?: number;
    active?: boolean;
};

export type RuleTrigger = {
    readonly id?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    type: RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     */
    value: string;
    /**
     * If 'prohibited' is true, this rule trigger will be negated. 'Description is' will become 'Description is NOT' etc.
     */
    prohibited?: boolean;
    /**
     * Order of the trigger
     */
    readonly order?: number;
    /**
     * If the trigger is active. Defaults to true.
     */
    active?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
     */
    stop_processing?: boolean;
};

export type RuleTriggerStore = {
    type: RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     */
    value: string;
    /**
     * Order of the trigger
     */
    order?: number;
    /**
     * If the trigger is active. Defaults to true.
     */
    active?: boolean;
    /**
     * If 'prohibited' is true, this rule trigger will be negated. 'Description is' will become 'Description is NOT' etc.
     */
    prohibited?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
     */
    stop_processing?: boolean;
};

export type RuleTriggerUpdate = {
    type?: RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger. If the rule trigger is something like 'has any tag', submit the string 'true'.
     */
    value?: string;
    /**
     * Order of the trigger
     */
    order?: number;
    /**
     * If the trigger is active.
     */
    active?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered.
     */
    stop_processing?: boolean;
};

/**
 * A single tag (C)
 */
export type TagModel = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * The tag
     */
    tag: string;
    /**
     * The date to which the tag is applicable.
     */
    date?: string | null;
    description?: string | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
};

/**
 * A single tag (A)
 */
export type TagModelStore = {
    /**
     * The tag
     */
    tag: string;
    /**
     * The date to which the tag is applicable.
     */
    date?: string | null;
    description?: string | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
};

/**
 * A single tag (B)
 */
export type TagModelUpdate = {
    /**
     * The tag
     */
    tag?: string;
    /**
     * The date to which the tag is applicable.
     */
    date?: string | null;
    description?: string | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
};

export type CurrencyProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Defaults to true
     */
    enabled?: boolean;
    /**
     * Is the primary currency?
     */
    primary?: boolean;
    code: string;
    name: string;
    symbol: string;
    /**
     * Supports 0-16 decimals.
     */
    decimal_places?: number;
};

export type CurrencyStore = {
    /**
     * Defaults to true
     */
    enabled?: boolean;
    /**
     * Make this currency the primary currency for the current administration. You can set this value to FALSE, in which case nothing will change to the primary currency. If you set it to TRUE, the current primary currency will no longer be the primary currency.
     */
    primary?: boolean;
    code: string;
    name: string;
    symbol: string;
    /**
     * Supports 0-16 decimals.
     */
    decimal_places?: number;
};

export type CurrencyUpdate = {
    /**
     * If the currency is enabled
     */
    enabled?: boolean;
    /**
     * If the currency must be the primary for the user. You can only submit TRUE. Submitting FALSE will not drop this currency as the primary currency, because then the system would be without one.
     */
    primary?: true;
    /**
     * The currency code
     */
    code?: string;
    /**
     * The currency name
     */
    name?: string;
    /**
     * The currency symbol
     */
    symbol?: string;
    /**
     * How many decimals to use when displaying this currency. Between 0 and 16.
     */
    decimal_places?: number;
};

export type Transaction = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * User ID
     */
    readonly user?: string;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions: Array<TransactionSplit>;
};

export type TransactionStore = {
    /**
     * Break if the submitted transaction exists already.
     */
    error_if_duplicate_hash?: boolean;
    /**
     * Whether or not to apply rules when submitting transaction.
     */
    apply_rules?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions: Array<TransactionSplitStore>;
};

export type TransactionUpdate = {
    /**
     * Whether or not to apply rules when submitting transaction.
     */
    apply_rules?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions?: Array<TransactionSplitUpdate>;
};

export type TransactionLink = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id: string;
    /**
     * Optional. Some notes.
     */
    notes?: string | null;
};

export type TransactionLinkStore = {
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id: string;
    /**
     * Optional. Some notes.
     */
    notes?: string | null;
};

export type TransactionLinkUpdate = {
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id?: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id?: string;
    /**
     * Optional. Some notes. If you submit an empty string the current notes will be removed
     */
    notes?: string | null;
};

export type LinkType = {
    name: string;
    inward: string;
    outward: string;
    readonly editable?: boolean;
};

export type LinkTypeUpdate = {
    name?: string;
    inward?: string;
    outward?: string;
};

export type TransactionSplit = {
    /**
     * User ID
     */
    readonly user?: string;
    /**
     * ID of the underlying transaction journal. Each transaction consists of a transaction group (see the top ID) and one or more journals
     * making up the splits of the transaction.
     *
     */
    readonly transaction_journal_id?: string;
    type: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Indicates whether the transaction has a currency setting. For transactions this is always true.
     */
    readonly object_has_currency_setting?: boolean;
    /**
     * Currency ID for the currency of this transaction.
     */
    currency_id?: string;
    /**
     * Currency code for the currency of this transaction.
     */
    currency_code?: string;
    /**
     * Currency symbol for the currency of this transaction.
     */
    readonly currency_symbol?: string;
    /**
     * Currency name for the currency of this transaction.
     */
    currency_name?: string;
    /**
     * Number of decimals used in this currency.
     */
    currency_decimal_places?: number;
    /**
     * Currency ID of the foreign currency, if this transaction has a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL.
     */
    foreign_currency_code?: string | null;
    readonly foreign_currency_symbol?: string | null;
    /**
     * Number of decimals in the foreign currency.
     */
    readonly foreign_currency_decimal_places?: number | null;
    /**
     * Returns the primary currency ID of the administration. This currency is used as the currency for all `pc_*` amount and balance fields of this account.
     */
    readonly primary_currency_id?: string | null;
    /**
     * Returns the primary currency code of the administration. This currency is used as the currency for all `pc_*` amount and balance fields of this account.
     */
    primary_currency_code?: string | null;
    /**
     * See the other `primary_*` fields.
     */
    readonly primary_currency_symbol?: string | null;
    /**
     * See the other `primary_*` fields.
     */
    readonly primary_currency_decimal_places?: number | null;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Amount of the transaction in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_amount?: string;
    /**
     * The amount in the set foreign currency. May be NULL if the transaction does not have a foreign amount.
     */
    foreign_amount?: string | null;
    /**
     * Foreign amount of the transaction in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_foreign_amount?: string;
    /**
     * The balance of the source account. This is the balance in the account's currency which may be different from this transaction, and is not provided in this model.
     */
    source_balance_after?: string | null;
    /**
     * The balance of the source account in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_source_balance_after?: string | null;
    /**
     * The balance of the destination account. This is the balance in the account's currency which may be different from this transaction, and is not provided in this model.
     */
    destination_balance_after?: string | null;
    /**
     * The balance of the destination account in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_destination_balance_after?: string | null;
    /**
     * Description of the transaction.
     */
    description: string;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    readonly source_iban?: string | null;
    source_type?: AccountTypeProperty;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    readonly destination_iban?: string | null;
    destination_type?: AccountTypeProperty;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The name of the budget used.
     */
    readonly budget_name?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * The associated subscription ID for this transaction. `bill` refers to the OLD name for subscriptions and this field will be removed.
     */
    bill_id?: string | null;
    /**
     * The associated subscription name for this transaction. `bill` refers to the OLD name for subscriptions and this field will be removed.
     */
    bill_name?: string | null;
    /**
     * The associated subscription ID for this transaction.
     */
    subscription_id?: string | null;
    /**
     * The associated subscription name for this transaction.
     */
    subscription_name?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    notes?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * System generated identifier for original creator of transaction.
     */
    readonly original_source?: string | null;
    /**
     * Reference to recurrence that made the transaction.
     */
    readonly recurrence_id?: string | null;
    /**
     * Total number of transactions expected to be created by this recurrence repetition. Will be 0 if infinite.
     */
    readonly recurrence_total?: number | null;
    /**
     * The # of the current transaction created under this recurrence.
     */
    readonly recurrence_count?: number | null;
    /**
     * Hash value of original import transaction (for duplicate detection).
     */
    readonly import_hash_v2?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
    /**
     * Latitude of the transaction's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the transaction's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
    /**
     * If the transaction has attachments.
     */
    has_attachments?: boolean;
};

export type TransactionSplitStore = {
    type: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date: string;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Description of the transaction.
     */
    description: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Currency ID. Default is the source account's currency, or the user's financial administration's currency. The value you submit may be overruled by the source or destination account.
     */
    currency_id?: string | null;
    /**
     * Currency code. Default is the source account's currency, or the user's financial administration's primary currency. The value you submit may be overruled by the source or destination account.
     */
    currency_code?: string | null;
    /**
     * The amount in a foreign currency.
     */
    foreign_amount?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     */
    foreign_currency_code?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     */
    budget_name?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    /**
     * Optional. Use either this or the bill_name
     */
    bill_id?: string | null;
    /**
     * Optional. Use either this or the bill_id
     */
    bill_name?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    notes?: string | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
};

export type TransactionSplitUpdate = {
    /**
     * Transaction journal ID of current transaction (split).
     */
    transaction_journal_id?: string;
    type?: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date?: string;
    /**
     * Amount of the transaction.
     */
    amount?: string;
    /**
     * Description of the transaction.
     */
    description?: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Currency ID. Default is the source account's currency, or the user's financial administration's primary currency. Can be used instead of currency_code.
     */
    currency_id?: string | null;
    /**
     * Currency code. Default is the source account's currency, or the user's financial administration's primary currency. Can be used instead of currency_id.
     */
    currency_code?: string | null;
    readonly currency_symbol?: string;
    readonly currency_name?: string;
    /**
     * Number of decimals used in this currency.
     */
    readonly currency_decimal_places?: number;
    /**
     * The amount in a foreign currency.
     */
    foreign_amount?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     */
    foreign_currency_code?: string | null;
    readonly foreign_currency_symbol?: string | null;
    /**
     * Number of decimals in the currency
     */
    readonly foreign_currency_decimal_places?: number | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     */
    readonly budget_name?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    source_iban?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    destination_iban?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    /**
     * Optional. Use either this or the bill_name
     */
    bill_id?: string | null;
    /**
     * Optional. Use either this or the bill_id
     */
    bill_name?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    notes?: string | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
};

/**
 * A single user
 */
export type User = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * The new users email address.
     */
    email: string;
    /**
     * Boolean to indicate if the user is blocked.
     */
    blocked?: boolean;
    blocked_code?: UserBlockedCodeProperty;
    role?: UserRoleProperty;
};

export type UserGroupRead = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: UserGroupReadAttributes;
    links: ObjectLink;
};

export type UserGroupReadAttributes = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Is this user group ('financial administration') currently the active administration?
     */
    readonly in_use?: boolean;
    /**
     * Can the current user see the members of this user group?
     */
    readonly can_see_members?: boolean;
    /**
     * Title of the user group. By default, it is the same as the user's email address.
     */
    title?: string;
    /**
     * Returns the primary currency ID of the user group.
     */
    readonly primary_currency_id?: string;
    /**
     * Returns the primary currency code of the user group.
     */
    primary_currency_code?: string;
    /**
     * Returns the primary currency symbol of the user group.
     */
    readonly primary_currency_symbol?: string;
    /**
     * Returns the primary currency decimal places of the user group.
     */
    readonly primary_currency_decimal_places?: number;
    members?: Array<UserGroupReadMembers>;
};

export type UserGroupReadMembers = {
    /**
     * The ID of the member.
     */
    readonly user_id?: string;
    /**
     * The email address of the member
     */
    readonly user_email?: string;
    /**
     * Is this you? (the current user)
     */
    readonly you?: boolean;
    roles?: Array<UserGroupReadRole>;
};

/**
 * The possible roles of the user in this user group are documented here: https://docs.firefly-iii.org/references/firefly-iii/api/
 *
 */
export type UserGroupReadRole = 'ro' | 'mng_trx' | 'mng_meta' | 'read_budgets' | 'read_piggies' | 'read_subscriptions' | 'read_rules' | 'read_recurring' | 'read_webhooks' | 'read_currencies' | 'mng_budgets' | 'mng_piggies' | 'mng_subscriptions' | 'mng_rules' | 'mng_recurring' | 'mng_webhooks' | 'mng_currencies' | 'view_reports' | 'view_memberships' | 'full' | 'owner';

export type UserGroupSingle = {
    data: UserGroupRead;
};

export type UserGroupUpdate = {
    /**
     * A descriptive title for the user group.
     */
    title: string;
    /**
     * Use either primary_currency_id or primary_currency_code. This will set the primary currency for the user group ('financial administration').
     */
    primary_currency_id?: string;
    /**
     * Use either primary_currency_id or primary_currency_code. This will set the primary currency for the user group ('financial administration').
     */
    primary_currency_code?: string;
};

/**
 * Format of the delivered response.
 */
export type WebhookDelivery = 'JSON';

export type WebhookDeliveryArray = [
    WebhookDelivery
];

/**
 * A single webhook (read)
 */
export type WebhookProperties = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * Boolean to indicate if the webhook is active
     */
    active?: boolean;
    /**
     * A title for the webhook for easy recognition.
     */
    title: string;
    /**
     * A 24-character secret for the webhook. It's generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
     */
    readonly secret?: string;
    triggers?: WebhookTriggerArray;
    responses?: WebhookResponseArray;
    deliveries?: WebhookDeliveryArray;
    /**
     * The URL of the webhook. Has to start with `https`.
     */
    url: string;
};

/**
 * Indicator for what Firefly III will deliver to the webhook URL.
 */
export type WebhookResponse = 'TRANSACTIONS' | 'ACCOUNTS' | 'BUDGET' | 'RELEVANT' | 'NONE';

export type WebhookResponseArray = [
    WebhookResponse
];

/**
 * A single webhook (store)
 */
export type WebhookStore = {
    /**
     * Boolean to indicate if the webhook is active
     */
    active?: boolean;
    /**
     * A title for the webhook for easy recognition.
     */
    title: string;
    triggers?: WebhookTriggerArray;
    responses?: WebhookResponseArray;
    deliveries?: WebhookDeliveryArray;
    /**
     * The URL of the webhook. Has to start with `https`.
     */
    url: string;
};

/**
 * The trigger for the webhook.
 */
export type WebhookTrigger = 'ANY' | 'STORE_TRANSACTION' | 'UPDATE_TRANSACTION' | 'DESTROY_TRANSACTION' | 'STORE_BUDGET' | 'UPDATE_BUDGET' | 'DESTROY_BUDGET' | 'STORE_UPDATE_BUDGET_LIMIT';

export type WebhookTriggerArray = Array<WebhookTrigger>;

/**
 * A single webhook (update)
 */
export type WebhookUpdate = {
    /**
     * Boolean to indicate if the webhook is active
     */
    active?: boolean;
    /**
     * A title for the webhook for easy recognition.
     */
    title?: string;
    /**
     * A 24-character secret for the webhook. It's generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
     */
    secret?: string;
    triggers?: WebhookTriggerArray;
    responses?: WebhookResponseArray;
    deliveries?: WebhookDeliveryArray;
    /**
     * The URL of the webhook. Has to start with `https`.
     */
    url?: string;
};

export type WebhookAttempt = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * The ID of the webhook message this attempt belongs to.
     */
    webhook_message_id?: string;
    /**
     * The HTTP status code of the error, if any.
     */
    status_code?: number | null;
    /**
     * Internal log for this attempt. May contain sensitive user data.
     */
    logs?: string | null;
    /**
     * Webhook receiver response for this attempt, if any. May contain sensitive user data.
     */
    response?: string | null;
};

export type WebhookMessage = {
    readonly created_at?: string;
    readonly updated_at?: string;
    /**
     * If this message is sent yet.
     */
    sent?: boolean;
    /**
     * If this message has errored out.
     */
    errored?: boolean;
    /**
     * The ID of the webhook this message belongs to.
     */
    webhook_id?: string;
    /**
     * Long UUID string for identification of this webhook message.
     */
    uuid?: string;
    /**
     * The actual message that is sent or will be sent as JSON string.
     */
    message?: string | null;
};

/**
 * The object class to which the attachment must be linked.
 */
export type AttachableType = 'Account' | 'Budget' | 'Bill' | 'TransactionJournal' | 'PiggyBank' | 'Tag';

/**
 * Period for the auto budget
 */
export type AutoBudgetPeriod = 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'half-year' | 'yearly' | null;

/**
 * The type of auto-budget that Firefly III must create.
 */
export type AutoBudgetType = 'reset' | 'rollover' | 'none' | null;

/**
 * How often the bill must be paid.
 */
export type BillRepeatFrequency = 'weekly' | 'monthly' | 'quarterly' | 'half-year' | 'yearly';

export type PolymorphicProperty = boolean | string | Array<StringArrayItem>;

/**
 * The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
 */
export type RecurrenceRepetitionType = 'daily' | 'weekly' | 'ndom' | 'monthly' | 'yearly';

export type RecurrenceTransactionType = 'withdrawal' | 'transfer' | 'deposit';

/**
 * The type of thing this action will do. A limited set is possible.
 */
export type RuleActionKeyword = 'user_action' | 'set_category' | 'clear_category' | 'set_budget' | 'clear_budget' | 'add_tag' | 'remove_tag' | 'remove_all_tags' | 'set_description' | 'append_description' | 'prepend_description' | 'set_source_account' | 'set_destination_account' | 'set_notes' | 'append_notes' | 'prepend_notes' | 'clear_notes' | 'link_to_bill' | 'convert_withdrawal' | 'convert_deposit' | 'convert_transfer' | 'delete_transaction';

/**
 * The type of thing this trigger responds to. A limited set is possible
 */
export type RuleTriggerKeyword = 'from_account_starts' | 'from_account_ends' | 'from_account_is' | 'from_account_contains' | 'to_account_starts' | 'to_account_ends' | 'to_account_is' | 'to_account_contains' | 'amount_less' | 'amount_exactly' | 'amount_more' | 'description_starts' | 'description_ends' | 'description_contains' | 'description_is' | 'transaction_type' | 'category_is' | 'budget_is' | 'tag_is' | 'currency_is' | 'has_attachments' | 'has_no_category' | 'has_any_category' | 'has_no_budget' | 'has_any_budget' | 'has_no_tag' | 'has_any_tag' | 'notes_contains' | 'notes_start' | 'notes_end' | 'notes_are' | 'no_notes' | 'any_notes' | 'source_account_is' | 'destination_account_is' | 'source_account_starts';

/**
 * Which action is necessary for the rule to fire? Use either store-journal, update-journal or manual-activation.
 */
export type RuleTriggerType = 'store-journal' | 'update-journal' | 'manual-activation';

/**
 * The actual preference content.
 */
export type StringArrayItem = string;

/**
 * If you say the user must be blocked, this will be the reason code.
 */
export type UserBlockedCodeProperty = 'email_changed' | null;

/**
 * Role for the user. Can be empty or omitted.
 */
export type UserRoleProperty = 'owner' | 'demo' | null;

export type BasicSummary = {
    [key: string]: BasicSummaryEntry;
};

export type BasicSummaryEntry = {
    /**
     * This is a reference to the type of info shared, not influenced by translations or user preferences. The EUR value is a reference to the currency code. Possibilities are: balance-in-ABC, spent-in-ABC, earned-in-ABC, bills-paid-in-ABC, bills-unpaid-in-ABC, left-to-spend-in-ABC and net-worth-in-ABC.
     */
    key?: string;
    /**
     * A translated title for the information shared.
     */
    title?: string;
    /**
     * The amount as a float.
     */
    monetary_value?: number;
    /**
     * The currency ID of the associated currency.
     */
    currency_id?: string;
    currency_code?: string;
    currency_symbol?: string;
    /**
     * Number of decimals for the associated currency.
     */
    currency_decimal_places?: number;
    /**
     * True if there are no available budgets available.
     */
    no_available_budgets?: boolean;
    /**
     * The amount formatted according to the users locale
     */
    value_parsed?: string;
    /**
     * Reference to a font-awesome icon without the fa- part.
     */
    local_icon?: string;
    /**
     * A short explanation of the amounts origin. Already formatted according to the locale of the user or translated, if relevant.
     */
    sub_title?: string;
};

export type Configuration = {
    title: ConfigValueFilter;
    value: PolymorphicProperty;
    /**
     * If this config variable can be edited by the user
     */
    editable: boolean;
};

export type ConfigurationUpdate = {
    value: PolymorphicProperty;
};

export type CronResult = {
    recurring_transactions?: CronResultRow;
    auto_budgets?: CronResultRow;
    telemetry?: CronResultRow;
};

export type CronResultRow = {
    /**
     * This value tells you if this specific cron job actually fired. It may not fire. Some cron jobs
     * only fire every 24 hours, for example.
     *
     */
    job_fired?: boolean | null;
    /**
     * This value tells you if this specific cron job actually did something. The job may fire but not
     * change anything.
     *
     */
    job_succeeded?: boolean | null;
    /**
     * If the cron job ran into some kind of an error, this value will be true.
     */
    job_errored?: boolean | null;
    /**
     * If the cron job ran into some kind of an error, this value will be the error message. The success message
     * if the job actually ran OK.
     *
     */
    message?: string | null;
};

export type SystemInfo = {
    data?: {
        version?: string;
        /**
         * Same value as the version field.
         */
        api_version?: string;
        php_version?: string;
        os?: string;
        driver?: string;
    };
};

export type UserSingle = {
    data: UserRead;
};

export type AccountTypeFilter = 'all' | 'asset' | 'cash' | 'expense' | 'revenue' | 'special' | 'hidden' | 'liability' | 'liabilities' | 'Default account' | 'Cash account' | 'Asset account' | 'Expense account' | 'Revenue account' | 'Initial balance account' | 'Beneficiary account' | 'Import account' | 'Reconciliation account' | 'Loan' | 'Debt' | 'Mortgage';

export type TransactionTypeFilter = 'all' | 'withdrawal' | 'withdrawals' | 'expense' | 'deposit' | 'deposits' | 'income' | 'transfer' | 'transfers' | 'opening_balance' | 'reconciliation' | 'special' | 'specials' | 'default';

export type Meta = {
    pagination?: {
        total?: number;
        count?: number;
        per_page?: number;
        current_page?: number;
        total_pages?: number;
    };
};

/**
 * Is only mandatory when the type is asset.
 */
export type AccountRoleProperty = 'defaultAsset' | 'sharedAsset' | 'savingAsset' | 'ccAsset' | 'cashWalletAsset' | null;

export type AccountTypeProperty = 'Default account' | 'Cash account' | 'Asset account' | 'Expense account' | 'Revenue account' | 'Initial balance account' | 'Beneficiary account' | 'Import account' | 'Reconciliation account' | 'Loan' | 'Debt' | 'Mortgage';

/**
 * Period of the chart.
 */
export type ChartDatasetPeriodProperty = '1D' | '1W' | '1M' | '3M' | '1Y' | 'custom';

/**
 * Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
 */
export type CreditCardTypeProperty = 'monthlyFull' | null;

/**
 * Mandatory when type is liability. Period over which the interest is calculated.
 */
export type InterestPeriodProperty = 'weekly' | 'monthly' | 'quarterly' | 'half-year' | 'yearly' | null;

/**
 * 'credit' indicates somebody owes you the liability. 'debit' Indicates you owe this debt yourself. Works only for liabilities.
 */
export type LiabilityDirectionProperty = 'credit' | 'debit' | null;

/**
 * Mandatory when type is liability. Specifies the exact type.
 */
export type LiabilityTypeProperty = 'loan' | 'debt' | 'mortgage' | null;

/**
 * Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
 */
export type ShortAccountTypeProperty = 'asset' | 'expense' | 'import' | 'revenue' | 'cash' | 'liability' | 'liabilities' | 'initial-balance' | 'reconciliation';

export type TransactionTypeProperty = 'withdrawal' | 'deposit' | 'transfer' | 'reconciliation' | 'opening balance';

export type BadRequestResponse = {
    message?: string;
    exception?: string;
};

export type InternalExceptionResponse = {
    message?: string;
    exception?: string;
};

export type NotFoundResponse = {
    message?: string;
    exception?: string;
};

export type UnauthenticatedResponse = {
    message?: string;
    exception?: string;
};

export type ValidationErrorResponse = {
    message?: string;
    errors?: {
        email?: Array<string>;
        force?: Array<string>;
        blocked?: Array<string>;
        field?: Array<string>;
        role?: Array<string>;
        blocked_code?: Array<string>;
        name?: Array<string>;
        type?: Array<string>;
        iban?: Array<string>;
        start?: Array<string>;
        end?: Array<string>;
        date?: Array<string>;
    };
};

export type AccountArrayWritable = {
    data: Array<AccountReadWritable>;
    meta: Meta;
};

export type AttachmentArrayWritable = {
    data: Array<AttachmentReadWritable>;
    meta: Meta;
};

export type AvailableBudgetArrayWritable = {
    data: Array<AvailableBudgetReadWritable>;
    meta: Meta;
};

export type BillArrayWritable = {
    data: Array<BillReadWritable>;
    meta: Meta;
};

export type BudgetArrayWritable = {
    data: Array<BudgetReadWritable>;
    meta: Meta;
};

export type BudgetLimitArrayWritable = {
    data: Array<BudgetLimitReadWritable>;
    meta: Meta;
};

export type CategoryArrayWritable = {
    data: Array<CategoryReadWritable>;
    meta: Meta;
};

export type CurrencyArrayWritable = {
    data: Array<CurrencyReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type CurrencyExchangeRateArrayWritable = {
    data: Array<CurrencyExchangeRateReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type LinkTypeArrayWritable = {
    data: Array<LinkTypeReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type ObjectGroupArrayWritable = {
    data: Array<ObjectGroupReadWritable>;
    meta: Meta;
};

export type PiggyBankArrayWritable = {
    data: Array<PiggyBankReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type PiggyBankEventArrayWritable = {
    data: Array<PiggyBankEventReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type PreferenceArrayWritable = {
    data: Array<PreferenceReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type RecurrenceArrayWritable = {
    data: Array<RecurrenceReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type RuleArrayWritable = {
    data: Array<RuleReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type RuleGroupArrayWritable = {
    data: Array<RuleGroupReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type TagArrayWritable = {
    data: Array<TagReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type TransactionArrayWritable = {
    data: Array<TransactionReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type TransactionLinkArrayWritable = {
    data: Array<TransactionLinkReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type UserArrayWritable = {
    data: Array<UserReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type UserGroupArrayWritable = {
    data: Array<UserGroupReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type WebhookArrayWritable = {
    data: Array<WebhookReadWritable>;
    meta: Meta;
    links: PageLink;
};

export type WebhookAttemptArrayWritable = {
    data: Array<WebhookAttemptReadWritable>;
    meta: Meta;
};

export type WebhookMessageArrayWritable = {
    data: Array<WebhookMessageReadWritable>;
    meta: Meta;
};

export type ChartDataSetWritable = {
    /**
     * This is the title of the current set. It can refer to an account, a budget or another object (by name).
     */
    label?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    date?: string;
    start_date?: string;
    end_date?: string;
    /**
     * Indicated the type of chart that is expected to be rendered. You can safely ignore this if you want.
     */
    type?: string;
    period?: ChartDatasetPeriodProperty;
    /**
     * Used to indicate the Y axis for this data set. Is usually between 0 and 1 (left and right side of the chart).
     */
    yAxisID?: number;
    /**
     * The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value.
     */
    entries?: {
        [key: string]: unknown;
    };
    /**
     * The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value.
     */
    pc_entries?: {
        [key: string]: unknown;
    };
};

export type ChartLineWritable = Array<ChartDataSetWritable>;

export type CategoryReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: CategoryPropertiesWritable;
};

export type CategorySingleWritable = {
    data: CategoryReadWritable;
};

export type CurrencyReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: CurrencyPropertiesWritable;
};

export type CurrencySingleWritable = {
    data: CurrencyReadWritable;
};

export type LinkTypeReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: LinkTypeWritable;
    links: ObjectLink;
};

export type LinkTypeSingleWritable = {
    data: LinkTypeReadWritable;
};

export type ObjectGroupReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: ObjectGroupWritable;
};

export type ObjectGroupSingleWritable = {
    data: ObjectGroupReadWritable;
};

export type PiggyBankEventReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: PiggyBankEventPropertiesWritable;
    links: ObjectLink;
};

export type PiggyBankReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: PiggyBankPropertiesWritable;
    links: ObjectLink;
};

export type PiggyBankSingleWritable = {
    data: PiggyBankReadWritable;
};

export type PreferenceReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: PreferenceWritable;
};

export type PreferenceSingleWritable = {
    data: PreferenceReadWritable;
};

export type RecurrenceReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: RecurrencePropertiesWritable;
    links: ObjectLink;
};

export type RecurrenceSingleWritable = {
    data: RecurrenceReadWritable;
};

export type RuleGroupReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: RuleGroupWritable;
    links: ObjectLink;
};

export type RuleGroupSingleWritable = {
    data: RuleGroupReadWritable;
};

export type RuleReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: RuleWritable;
    links: ObjectLink;
};

export type RuleSingleWritable = {
    data: RuleReadWritable;
};

export type TagReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: TagModelWritable;
    links: ObjectLink;
};

export type TagSingleWritable = {
    data: TagReadWritable;
};

export type TransactionLinkReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: TransactionLinkWritable;
    links: ObjectLink;
};

export type TransactionLinkSingleWritable = {
    data: TransactionLinkReadWritable;
};

export type TransactionReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: TransactionWritable;
    links: ObjectLink;
};

export type TransactionSingleWritable = {
    data: TransactionReadWritable;
};

export type UserReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: UserWritable;
    links: ObjectLink;
};

export type WebhookAttemptReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookAttemptWritable;
};

export type WebhookAttemptSingleWritable = {
    data: WebhookAttemptReadWritable;
};

export type WebhookMessageReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookMessageWritable;
};

export type WebhookMessageSingleWritable = {
    data: WebhookMessageReadWritable;
};

export type WebhookReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: WebhookPropertiesWritable;
    links: ObjectLink;
};

export type WebhookSingleWritable = {
    data: WebhookReadWritable;
};

export type AccountPropertiesWritable = {
    active?: boolean;
    /**
     * Order of the account. Is NULL if account is not asset or liability.
     */
    order?: number | null;
    name: string;
    type: ShortAccountTypeProperty;
    account_role?: AccountRoleProperty;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * Represents the opening balance, the initial amount this account holds in the currency of the account or the administration's primary currency if the account has no currency. Either way, the `currency_*` fields reflect the currency used.
     */
    opening_balance?: string;
    /**
     * The opening balance of the account in the administration's primary currency (pc). The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_opening_balance?: string;
    /**
     * The virtual balance of the account in the account's currency or the administration's primary currency if the account has no currency.
     */
    virtual_balance?: string;
    /**
     * The virtual balance of the account in the administration's primary currency (pc). The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_virtual_balance?: string;
    /**
     * In liability accounts (loans, debts and mortgages), this is the amount of debt in the account's currency (see the `currency_*` fields). In asset accounts, this is NULL.
     */
    debt_amount?: string | null;
    /**
     * In liability accounts (loans, debts and mortgages), this is the amount of debt in the administration's primary currency (see the `currency_*` fields. In asset accounts, this is NULL.
     */
    pc_debt_amount?: string | null;
    notes?: string | null;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     */
    monthly_payment_date?: string | null;
    credit_card_type?: CreditCardTypeProperty;
    account_number?: string | null;
    iban?: string | null;
    bic?: string | null;
    /**
     * Represents the date of the opening balance.
     */
    opening_balance_date?: string | null;
    liability_type?: LiabilityTypeProperty;
    liability_direction?: LiabilityDirectionProperty;
    /**
     * Mandatory when type is liability. Interest percentage.
     */
    interest?: string | null;
    interest_period?: InterestPeriodProperty;
    include_net_worth?: boolean;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Latitude of the accounts's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
    /**
     * Last activity of the account.
     */
    last_activity?: string | null;
};

export type AccountReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AccountPropertiesWritable;
};

export type AccountSingleWritable = {
    data: AccountReadWritable;
};

export type AttachmentPropertiesWritable = {
    attachable_type?: AttachableType;
    /**
     * ID of the model this attachment is linked to.
     */
    attachable_id?: string;
    /**
     * Hash of the file for basic duplicate detection.
     */
    hash?: string;
    filename?: string;
    download_url?: string;
    upload_url?: string;
    title?: string | null;
    notes?: string | null;
};

export type AttachmentReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AttachmentPropertiesWritable;
    links: ObjectLink;
};

export type AttachmentSingleWritable = {
    data: AttachmentReadWritable;
};

export type AvailableBudgetPropertiesWritable = {
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * The amount of this available budget in the currency of this available budget.
     */
    amount?: string;
    /**
     * The amount of this available budget in the primary currency (pc) of this administration.
     */
    pc_amount?: string;
    /**
     * Start date of the available budget.
     */
    start?: string;
    /**
     * End date of the available budget.
     */
    end?: string;
};

export type AvailableBudgetReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: AvailableBudgetPropertiesWritable;
};

export type AvailableBudgetSingleWritable = {
    data: AvailableBudgetReadWritable;
};

export type BillPropertiesWritable = {
    /**
     * The name of the subscription.
     */
    name?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * The minimum amount that is expected for this subscription in the subscription's currency.
     */
    amount_min?: string;
    /**
     * The minimum amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_min?: string;
    /**
     * The maximum amount that is expected for this subscription in the subscription's currency.
     */
    amount_max?: string;
    /**
     * The maximum amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_max?: string;
    /**
     * The average amount that is expected for this subscription in the subscription's currency.
     */
    amount_avg?: string;
    /**
     * The average amount that is expected for this subscription in the administration's primary currency.
     */
    pc_amount_avg?: string;
    date?: string;
    /**
     * The date after which this subscription is no longer valid or applicable
     */
    end_date?: string | null;
    /**
     * The date before which the subscription must be renewed (or cancelled)
     */
    extension_date?: string | null;
    repeat_freq?: BillRepeatFrequency;
    /**
     * How often the subscription will be skipped. 1 means a bi-monthly subscription.
     */
    skip?: number;
    /**
     * If the subscription is active.
     */
    active?: boolean;
    /**
     * Order of the subscription.
     */
    order?: number;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type BillReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BillPropertiesWritable;
};

export type BillSingleWritable = {
    data: BillReadWritable;
};

export type BudgetPropertiesWritable = {
    active?: boolean;
    name: string;
    notes?: string | null;
    auto_budget_type?: AutoBudgetType;
    auto_budget_period?: AutoBudgetPeriod;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * The amount for the auto-budget, if set.
     */
    auto_budget_amount?: string | null;
    /**
     * The amount for the auto-budget, if set in the primary currency of the administration.
     */
    pc_auto_budget_amount?: string | null;
};

export type BudgetReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BudgetPropertiesWritable;
};

export type BudgetSingleWritable = {
    data: BudgetReadWritable;
};

export type BudgetStoreWritable = {
    name: string;
    active?: boolean;
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    auto_budget_type?: AutoBudgetType;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_id?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user's financial administration's currency.
     */
    auto_budget_currency_code?: string | null;
    auto_budget_amount?: string | null;
    auto_budget_period?: AutoBudgetPeriod;
};

export type BudgetLimitPropertiesWritable = {
    /**
     * Start date of the budget limit.
     */
    start?: string;
    /**
     * End date of the budget limit.
     */
    end?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    amount?: string;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
};

export type BudgetLimitReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: BudgetLimitPropertiesWritable;
};

export type BudgetLimitSingleWritable = {
    data: BudgetLimitReadWritable;
};

export type BudgetLimitStoreWritable = {
    /**
     * Use either currency_id or currency_code. Defaults to the user's primary currency.
     */
    currency_id?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user's primary currency.
     */
    currency_code?: string;
    /**
     * Start date of the budget limit.
     */
    start: string;
    /**
     * End date of the budget limit.
     */
    end: string;
    amount: string;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
};

export type BudgetLimitUpdateWritable = {
    /**
     * Start date of the budget limit.
     */
    start?: string;
    /**
     * End date of the budget limit.
     */
    end?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    amount?: string;
    /**
     * Some notes for this specific budget limit.
     */
    notes?: string | null;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
};

export type CategoryPropertiesWritable = {
    name: string;
    notes?: string | null;
    /**
     * This object never has its own currency setting, so this value is always false.
     */
    object_has_currency_setting?: boolean;
};

export type CurrencyExchangeRateReadWritable = {
    links?: ObjectLink;
};

export type CurrencyExchangeRateSingleWritable = {
    data: CurrencyExchangeRateReadWritable;
};

export type ObjectGroupWritable = {
    title: string;
    /**
     * Order of the object group
     */
    order: number;
};

export type PiggyBankAccountReadWritable = {
    current_amount?: string;
    /**
     * If convertToPrimary is on, this will show the amount in the primary currency.
     */
    pc_current_amount?: string;
};

export type PiggyBankPropertiesWritable = {
    name: string;
    /**
     * The date you started with this piggy bank.
     */
    start_date?: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
    accounts?: Array<PiggyBankAccountReadWritable>;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    target_amount: string | null;
    /**
     * The target amount in the primary currency of the administration.
     */
    pc_target_amount?: string | null;
    current_amount?: string;
    /**
     * The current amount in the primary currency of the administration.
     */
    pc_current_amount?: string;
    left_to_save?: string | null;
    pc_left_to_save?: string | null;
};

export type PiggyBankStoreWritable = {
    name: string;
    accounts?: Array<PiggyBankAccountStore>;
    target_amount: string | null;
    current_amount?: string;
    /**
     * The date you started with this piggy bank.
     */
    start_date: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type PiggyBankUpdateWritable = {
    name?: string;
    accounts?: Array<PiggyBankAccountUpdate>;
    target_amount?: string | null;
    /**
     * The date you started with this piggy bank.
     */
    start_date?: string;
    /**
     * The date you intend to finish saving money.
     */
    target_date?: string | null;
    order?: number;
    notes?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     */
    object_group_id?: string | null;
    /**
     * The name of the group. NULL if no group.
     */
    object_group_title?: string | null;
};

export type PiggyBankEventPropertiesWritable = {
    created_at?: string;
    updated_at?: string;
    amount?: string;
    pc_amount?: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * The journal associated with the event.
     */
    transaction_journal_id?: string | null;
    /**
     * The transaction group associated with the event.
     */
    transaction_group_id?: string | null;
};

export type PreferenceWritable = {
    name: string;
    data: PolymorphicPropertyWritable;
};

export type RecurrencePropertiesWritable = {
    type?: RecurrenceTransactionType;
    title?: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     */
    description?: string;
    /**
     * First time the recurring transaction will fire. Must be after today.
     */
    first_date?: string;
    /**
     * Date until the recurring transaction can fire. Use either this field or repetitions.
     */
    repeat_until?: string | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     */
    apply_rules?: boolean;
    /**
     * If the recurrence is even active.
     */
    active?: boolean;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     */
    nr_of_repetitions?: number | null;
    notes?: string | null;
    repetitions?: Array<RecurrenceRepetitionWritable>;
    transactions?: Array<RecurrenceTransactionWritable>;
};

export type RecurrenceRepetitionWritable = {
    type: RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition.
     * - For 'daily', this is empty.
     * - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
     * - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
     * - For 'monthly' it is the day of the month (1 - 31)
     * - For yearly, it is a full date, ie '2025-11-01'. The year you use does not matter.
     *
     */
    moment: string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     */
    skip?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values:
     * 1. Do nothing, just create it
     * 2. Create no transaction.
     * 3. Skip to the previous Friday.
     * 4. Skip to the next Monday.
     *
     */
    weekend?: number;
};

export type RecurrenceTransactionWritable = {
    id?: string;
    description: string;
    /**
     * The currency ID of the currency associated with this object.
     */
    currency_id?: string;
    /**
     * The currency name of the currency associated with this object.
     */
    currency_name?: string;
    /**
     * The currency code of the currency associated with this object.
     */
    currency_code?: string;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Amount of the transaction in primary currency.
     */
    pc_amount?: string;
    /**
     * Foreign amount of the transaction.
     */
    foreign_amount?: string | null;
    /**
     * Foreign amount of the transaction.
     */
    pc_foreign_amount?: string | null;
    foreign_currency_id?: string | null;
    foreign_currency_name?: string | null;
    foreign_currency_code?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string;
    /**
     * Category ID for this transaction.
     */
    category_id?: string;
    /**
     * Category name for this transaction.
     */
    category_name?: string;
    /**
     * ID of the source account. Submit either this or source_name.
     */
    source_id?: string;
    /**
     * Name of the source account. Submit either this or source_id.
     */
    source_name?: string;
    /**
     * ID of the destination account. Submit either this or destination_name.
     */
    destination_id?: string;
    /**
     * Name of the destination account. Submit either this or destination_id.
     */
    destination_name?: string;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    piggy_bank_id?: string | null;
    piggy_bank_name?: string | null;
    subscription_id?: string | null;
    subscription_name?: string | null;
};

export type RuleWritable = {
    title: string;
    description?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     */
    rule_group_id: string;
    /**
     * Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
     */
    rule_group_title?: string;
    trigger: RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     */
    active?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     */
    strict?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     */
    stop_processing?: boolean;
    triggers: Array<RuleTriggerWritable>;
    actions: Array<RuleActionWritable>;
};

export type RuleActionWritable = {
    type: RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     */
    value: string | null;
    /**
     * Order of the action
     */
    order?: number;
    /**
     * If the action is active. Defaults to true.
     */
    active?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired. Defaults to false.
     */
    stop_processing?: boolean;
};

export type RuleGroupWritable = {
    title: string;
    description?: string | null;
    active?: boolean;
};

export type RuleTriggerWritable = {
    type: RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     */
    value: string;
    /**
     * If 'prohibited' is true, this rule trigger will be negated. 'Description is' will become 'Description is NOT' etc.
     */
    prohibited?: boolean;
    /**
     * If the trigger is active. Defaults to true.
     */
    active?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
     */
    stop_processing?: boolean;
};

/**
 * A single tag (C)
 */
export type TagModelWritable = {
    /**
     * The tag
     */
    tag: string;
    /**
     * The date to which the tag is applicable.
     */
    date?: string | null;
    description?: string | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the tag's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
};

export type CurrencyPropertiesWritable = {
    /**
     * Defaults to true
     */
    enabled?: boolean;
    /**
     * Is the primary currency?
     */
    primary?: boolean;
    code: string;
    name: string;
    symbol: string;
    /**
     * Supports 0-16 decimals.
     */
    decimal_places?: number;
};

export type TransactionWritable = {
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions: Array<TransactionSplitWritable>;
};

export type TransactionStoreWritable = {
    /**
     * Break if the submitted transaction exists already.
     */
    error_if_duplicate_hash?: boolean;
    /**
     * Whether or not to apply rules when submitting transaction.
     */
    apply_rules?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions: Array<TransactionSplitStoreWritable>;
};

export type TransactionUpdateWritable = {
    /**
     * Whether or not to apply rules when submitting transaction.
     */
    apply_rules?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     */
    fire_webhooks?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     */
    group_title?: string | null;
    transactions?: Array<TransactionSplitUpdateWritable>;
};

export type TransactionLinkWritable = {
    /**
     * The link type ID to use. You can also use the link_type_name field.
     */
    link_type_id: string;
    /**
     * The link type name to use. You can also use the link_type_id field.
     */
    link_type_name?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id: string;
    /**
     * Optional. Some notes.
     */
    notes?: string | null;
};

export type TransactionLinkStoreWritable = {
    /**
     * The link type ID to use. You can also use the link_type_name field.
     */
    link_type_id: string;
    /**
     * The link type name to use. You can also use the link_type_id field.
     */
    link_type_name?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id: string;
    /**
     * Optional. Some notes.
     */
    notes?: string | null;
};

export type TransactionLinkUpdateWritable = {
    /**
     * The link type ID to use. Use this field OR use the link_type_name field.
     */
    link_type_id?: string;
    /**
     * The link type name to use. Use this field OR use the link_type_id field.
     */
    link_type_name?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
     */
    inward_id?: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
     */
    outward_id?: string;
    /**
     * Optional. Some notes. If you submit an empty string the current notes will be removed
     */
    notes?: string | null;
};

export type LinkTypeWritable = {
    name: string;
    inward: string;
    outward: string;
};

export type TransactionSplitWritable = {
    type: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Currency ID for the currency of this transaction.
     */
    currency_id?: string;
    /**
     * Currency code for the currency of this transaction.
     */
    currency_code?: string;
    /**
     * Currency name for the currency of this transaction.
     */
    currency_name?: string;
    /**
     * Number of decimals used in this currency.
     */
    currency_decimal_places?: number;
    /**
     * Currency ID of the foreign currency, if this transaction has a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL.
     */
    foreign_currency_code?: string | null;
    /**
     * Returns the primary currency code of the administration. This currency is used as the currency for all `pc_*` amount and balance fields of this account.
     */
    primary_currency_code?: string | null;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Amount of the transaction in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_amount?: string;
    /**
     * The amount in the set foreign currency. May be NULL if the transaction does not have a foreign amount.
     */
    foreign_amount?: string | null;
    /**
     * Foreign amount of the transaction in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_foreign_amount?: string;
    /**
     * The balance of the source account. This is the balance in the account's currency which may be different from this transaction, and is not provided in this model.
     */
    source_balance_after?: string | null;
    /**
     * The balance of the source account in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_source_balance_after?: string | null;
    /**
     * The balance of the destination account. This is the balance in the account's currency which may be different from this transaction, and is not provided in this model.
     */
    destination_balance_after?: string | null;
    /**
     * The balance of the destination account in the primary currency of this administration. The `primary_currency_*` fields reflect the currency used. This field is NULL if the user does have 'convert to primary' set to true in their settings.
     */
    pc_destination_balance_after?: string | null;
    /**
     * Description of the transaction.
     */
    description: string;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * The associated subscription ID for this transaction. `bill` refers to the OLD name for subscriptions and this field will be removed.
     */
    bill_id?: string | null;
    /**
     * The associated subscription name for this transaction. `bill` refers to the OLD name for subscriptions and this field will be removed.
     */
    bill_name?: string | null;
    /**
     * The associated subscription ID for this transaction.
     */
    subscription_id?: string | null;
    /**
     * The associated subscription name for this transaction.
     */
    subscription_name?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    notes?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
    /**
     * Latitude of the transaction's location, if applicable. Can be used to draw a map.
     */
    latitude?: number | null;
    /**
     * Latitude of the transaction's location, if applicable. Can be used to draw a map.
     */
    longitude?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     */
    zoom_level?: number | null;
    /**
     * If the transaction has attachments.
     */
    has_attachments?: boolean;
};

export type TransactionSplitStoreWritable = {
    type: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date: string;
    /**
     * Amount of the transaction.
     */
    amount: string;
    /**
     * Description of the transaction.
     */
    description: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Currency ID. Default is the source account's currency, or the user's financial administration's currency. The value you submit may be overruled by the source or destination account.
     */
    currency_id?: string | null;
    /**
     * Currency code. Default is the source account's currency, or the user's financial administration's primary currency. The value you submit may be overruled by the source or destination account.
     */
    currency_code?: string | null;
    /**
     * The amount in a foreign currency.
     */
    foreign_amount?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     */
    foreign_currency_code?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     */
    budget_name?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    /**
     * Optional. Use either this or the piggy_bank_name
     */
    piggy_bank_id?: number | null;
    /**
     * Optional. Use either this or the piggy_bank_id
     */
    piggy_bank_name?: string | null;
    /**
     * Optional. Use either this or the bill_name
     */
    bill_id?: string | null;
    /**
     * Optional. Use either this or the bill_id
     */
    bill_name?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    notes?: string | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
};

export type TransactionSplitUpdateWritable = {
    /**
     * Transaction journal ID of current transaction (split).
     */
    transaction_journal_id?: string;
    type?: TransactionTypeProperty;
    /**
     * Date of the transaction
     */
    date?: string;
    /**
     * Amount of the transaction.
     */
    amount?: string;
    /**
     * Description of the transaction.
     */
    description?: string;
    /**
     * Order of this entry in the list of transactions.
     */
    order?: number | null;
    /**
     * Currency ID. Default is the source account's currency, or the user's financial administration's primary currency. Can be used instead of currency_code.
     */
    currency_id?: string | null;
    /**
     * Currency code. Default is the source account's currency, or the user's financial administration's primary currency. Can be used instead of currency_id.
     */
    currency_code?: string | null;
    /**
     * The amount in a foreign currency.
     */
    foreign_amount?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     */
    foreign_currency_id?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     */
    foreign_currency_code?: string | null;
    /**
     * The budget ID for this transaction.
     */
    budget_id?: string | null;
    /**
     * The category ID for this transaction.
     */
    category_id?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     */
    category_name?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     */
    source_id?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     */
    source_name?: string | null;
    source_iban?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     */
    destination_id?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     */
    destination_name?: string | null;
    destination_iban?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     */
    reconciled?: boolean;
    /**
     * Optional. Use either this or the bill_name
     */
    bill_id?: string | null;
    /**
     * Optional. Use either this or the bill_id
     */
    bill_name?: string | null;
    /**
     * Array of tags.
     */
    tags?: Array<string> | null;
    notes?: string | null;
    /**
     * Reference to internal reference of other systems.
     */
    internal_reference?: string | null;
    /**
     * Reference to external ID in other systems.
     */
    external_id?: string | null;
    /**
     * External, custom URL for this transaction.
     */
    external_url?: string | null;
    /**
     * SEPA Clearing Code
     */
    sepa_cc?: string | null;
    /**
     * SEPA Opposing Account Identifier
     */
    sepa_ct_op?: string | null;
    /**
     * SEPA end-to-end Identifier
     */
    sepa_ct_id?: string | null;
    /**
     * SEPA mandate identifier
     */
    sepa_db?: string | null;
    /**
     * SEPA Country
     */
    sepa_country?: string | null;
    /**
     * SEPA External Purpose indicator
     */
    sepa_ep?: string | null;
    /**
     * SEPA Creditor Identifier
     */
    sepa_ci?: string | null;
    /**
     * SEPA Batch ID
     */
    sepa_batch_id?: string | null;
    interest_date?: string | null;
    book_date?: string | null;
    process_date?: string | null;
    due_date?: string | null;
    payment_date?: string | null;
    invoice_date?: string | null;
};

/**
 * A single user
 */
export type UserWritable = {
    /**
     * The new users email address.
     */
    email: string;
    /**
     * Boolean to indicate if the user is blocked.
     */
    blocked?: boolean;
    blocked_code?: UserBlockedCodeProperty;
    role?: UserRoleProperty;
};

export type UserGroupReadWritable = {
    /**
     * Immutable value
     */
    type: string;
    id: string;
    attributes: UserGroupReadAttributesWritable;
    links: ObjectLink;
};

export type UserGroupReadAttributesWritable = {
    /**
     * Title of the user group. By default, it is the same as the user's email address.
     */
    title?: string;
    /**
     * Returns the primary currency code of the user group.
     */
    primary_currency_code?: string;
    members?: Array<UserGroupReadMembersWritable>;
};

export type UserGroupReadMembersWritable = {
    roles?: Array<UserGroupReadRole>;
};

export type UserGroupSingleWritable = {
    data: UserGroupReadWritable;
};

export type WebhookDeliveryArrayWritable = [
    WebhookDelivery
];

/**
 * A single webhook (read)
 */
export type WebhookPropertiesWritable = {
    /**
     * Boolean to indicate if the webhook is active
     */
    active?: boolean;
    /**
     * A title for the webhook for easy recognition.
     */
    title: string;
    triggers?: WebhookTriggerArrayWritable;
    responses?: WebhookResponseArrayWritable;
    deliveries?: WebhookDeliveryArrayWritable;
    /**
     * The URL of the webhook. Has to start with `https`.
     */
    url: string;
};

export type WebhookResponseArrayWritable = [
    WebhookResponse
];

export type WebhookTriggerArrayWritable = Array<WebhookTrigger>;

export type WebhookAttemptWritable = {
    /**
     * The ID of the webhook message this attempt belongs to.
     */
    webhook_message_id?: string;
    /**
     * The HTTP status code of the error, if any.
     */
    status_code?: number | null;
    /**
     * Internal log for this attempt. May contain sensitive user data.
     */
    logs?: string | null;
    /**
     * Webhook receiver response for this attempt, if any. May contain sensitive user data.
     */
    response?: string | null;
};

export type WebhookMessageWritable = {
    /**
     * If this message is sent yet.
     */
    sent?: boolean;
    /**
     * If this message has errored out.
     */
    errored?: boolean;
    /**
     * The ID of the webhook this message belongs to.
     */
    webhook_id?: string;
    /**
     * Long UUID string for identification of this webhook message.
     */
    uuid?: string;
    /**
     * The actual message that is sent or will be sent as JSON string.
     */
    message?: string | null;
};

export type PolymorphicPropertyWritable = boolean | string | Array<StringArrayItem>;

export type UserSingleWritable = {
    data: UserReadWritable;
};

export type GetAccountsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
        /**
         * If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         */
        date?: string;
        /**
         * Optional filter on the account type(s) used in the autocomplete.
         */
        types?: Array<AccountTypeFilter>;
    };
    url: '/v1/autocomplete/accounts';
};

export type GetAccountsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetAccountsAcError = GetAccountsAcErrors[keyof GetAccountsAcErrors];

export type GetAccountsAcResponses = {
    /**
     * A list of accounts with very basic information.
     */
    200: AutocompleteAccountArray;
};

export type GetAccountsAcResponse = GetAccountsAcResponses[keyof GetAccountsAcResponses];

export type GetBillsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/bills';
};

export type GetBillsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBillsAcError = GetBillsAcErrors[keyof GetBillsAcErrors];

export type GetBillsAcResponses = {
    /**
     * A list of bills with very basic information.
     */
    200: AutocompleteBillArray;
};

export type GetBillsAcResponse = GetBillsAcResponses[keyof GetBillsAcResponses];

export type GetBudgetsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/budgets';
};

export type GetBudgetsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBudgetsAcError = GetBudgetsAcErrors[keyof GetBudgetsAcErrors];

export type GetBudgetsAcResponses = {
    /**
     * A list of budgets with very basic information.
     */
    200: AutocompleteBudgetArray;
};

export type GetBudgetsAcResponse = GetBudgetsAcResponses[keyof GetBudgetsAcResponses];

export type GetCategoriesAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/categories';
};

export type GetCategoriesAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCategoriesAcError = GetCategoriesAcErrors[keyof GetCategoriesAcErrors];

export type GetCategoriesAcResponses = {
    /**
     * A list of categories with very basic information.
     */
    200: AutocompleteCategoryArray;
};

export type GetCategoriesAcResponse = GetCategoriesAcResponses[keyof GetCategoriesAcResponses];

export type GetCurrenciesAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/currencies';
};

export type GetCurrenciesAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCurrenciesAcError = GetCurrenciesAcErrors[keyof GetCurrenciesAcErrors];

export type GetCurrenciesAcResponses = {
    /**
     * A list of currencies with very basic information.
     */
    200: AutocompleteCurrencyArray;
};

export type GetCurrenciesAcResponse = GetCurrenciesAcResponses[keyof GetCurrenciesAcResponses];

export type GetCurrenciesCodeAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/currencies-with-code';
};

export type GetCurrenciesCodeAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCurrenciesCodeAcError = GetCurrenciesCodeAcErrors[keyof GetCurrenciesCodeAcErrors];

export type GetCurrenciesCodeAcResponses = {
    /**
     * A list of currencies with very basic information and the currency code between brackets. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     */
    200: AutocompleteCurrencyCodeArray;
};

export type GetCurrenciesCodeAcResponse = GetCurrenciesCodeAcResponses[keyof GetCurrenciesCodeAcResponses];

export type GetObjectGroupsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/object-groups';
};

export type GetObjectGroupsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetObjectGroupsAcError = GetObjectGroupsAcErrors[keyof GetObjectGroupsAcErrors];

export type GetObjectGroupsAcResponses = {
    /**
     * A list of object groups with very basic information.
     */
    200: AutocompleteObjectGroupArray;
};

export type GetObjectGroupsAcResponse = GetObjectGroupsAcResponses[keyof GetObjectGroupsAcResponses];

export type GetPiggiesAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/piggy-banks';
};

export type GetPiggiesAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetPiggiesAcError = GetPiggiesAcErrors[keyof GetPiggiesAcErrors];

export type GetPiggiesAcResponses = {
    /**
     * A list of piggy banks with very basic information.
     */
    200: AutocompletePiggyArray;
};

export type GetPiggiesAcResponse = GetPiggiesAcResponses[keyof GetPiggiesAcResponses];

export type GetPiggiesBalanceAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/piggy-banks-with-balance';
};

export type GetPiggiesBalanceAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetPiggiesBalanceAcError = GetPiggiesBalanceAcErrors[keyof GetPiggiesBalanceAcErrors];

export type GetPiggiesBalanceAcResponses = {
    /**
     * A list of piggy banks with very basic balance information.
     */
    200: AutocompletePiggyBalanceArray;
};

export type GetPiggiesBalanceAcResponse = GetPiggiesBalanceAcResponses[keyof GetPiggiesBalanceAcResponses];

export type GetRecurringAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/recurring';
};

export type GetRecurringAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRecurringAcError = GetRecurringAcErrors[keyof GetRecurringAcErrors];

export type GetRecurringAcResponses = {
    /**
     * A list of recurring transactions with very basic information.
     */
    200: AutocompleteRecurrenceArray;
};

export type GetRecurringAcResponse = GetRecurringAcResponses[keyof GetRecurringAcResponses];

export type GetRuleGroupsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/rule-groups';
};

export type GetRuleGroupsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRuleGroupsAcError = GetRuleGroupsAcErrors[keyof GetRuleGroupsAcErrors];

export type GetRuleGroupsAcResponses = {
    /**
     * A list of rule groups with very basic information.
     */
    200: AutocompleteRuleGroupArray;
};

export type GetRuleGroupsAcResponse = GetRuleGroupsAcResponses[keyof GetRuleGroupsAcResponses];

export type GetRulesAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/rules';
};

export type GetRulesAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRulesAcError = GetRulesAcErrors[keyof GetRulesAcErrors];

export type GetRulesAcResponses = {
    /**
     * A list of rules with very basic information.
     */
    200: AutocompleteRuleArray;
};

export type GetRulesAcResponse = GetRulesAcResponses[keyof GetRulesAcResponses];

export type GetSubscriptionsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/subscriptions';
};

export type GetSubscriptionsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetSubscriptionsAcError = GetSubscriptionsAcErrors[keyof GetSubscriptionsAcErrors];

export type GetSubscriptionsAcResponses = {
    /**
     * A list of subscriptions with very basic information.
     */
    200: AutocompleteBillArray;
};

export type GetSubscriptionsAcResponse = GetSubscriptionsAcResponses[keyof GetSubscriptionsAcResponses];

export type GetTagAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/tags';
};

export type GetTagAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTagAcError = GetTagAcErrors[keyof GetTagAcErrors];

export type GetTagAcResponses = {
    /**
     * A list of tags with very basic information.
     */
    200: AutocompleteTagArray;
};

export type GetTagAcResponse = GetTagAcResponses[keyof GetTagAcResponses];

export type GetTransactionTypesAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/transaction-types';
};

export type GetTransactionTypesAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionTypesAcError = GetTransactionTypesAcErrors[keyof GetTransactionTypesAcErrors];

export type GetTransactionTypesAcResponses = {
    /**
     * A list of transaction types with very basic information.
     */
    200: AutocompleteTransactionTypeArray;
};

export type GetTransactionTypesAcResponse = GetTransactionTypesAcResponses[keyof GetTransactionTypesAcResponses];

export type GetTransactionsAcData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/transactions';
};

export type GetTransactionsAcErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionsAcError = GetTransactionsAcErrors[keyof GetTransactionsAcErrors];

export type GetTransactionsAcResponses = {
    /**
     * A list of transaction descriptions with very basic information.
     */
    200: AutocompleteTransactionArray;
};

export type GetTransactionsAcResponse = GetTransactionsAcResponses[keyof GetTransactionsAcResponses];

export type GetTransactionsIdacData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The autocomplete search query.
         */
        query?: string;
        /**
         * The number of items returned.
         */
        limit?: number;
    };
    url: '/v1/autocomplete/transactions-with-id';
};

export type GetTransactionsIdacErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionsIdacError = GetTransactionsIdacErrors[keyof GetTransactionsIdacErrors];

export type GetTransactionsIdacResponses = {
    /**
     * A list of transactions with very basic information. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     */
    200: AutocompleteTransactionIdArray;
};

export type GetTransactionsIdacResponse = GetTransactionsIdacResponses[keyof GetTransactionsIdacResponses];

export type GetChartAccountOverviewData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * Optional period to group the data by. If not provided, it will default to '1M' or whatever is deemed relevant for the range provided.
         *
         * If you want to know which periods are available, see the enums or get the configuration value: `GET /api/v1/configuration/firefly.valid_view_ranges`
         *
         */
        period?: '1D' | '1W' | '1M' | '3M' | '6M' | '1Y';
        /**
         * Optional set of preselected accounts to limit the chart to. This may be easier than submitting all asset accounts manually, for example.
         * If you want to know which selection are available, see the enums here or get the configuration value: `GET /api/v1/configuration/firefly.preselected_accounts`
         *
         * - `empty`: do not do a pre-selection
         * - `all`: select all asset and all liability accounts
         * - `assets`: select all asset accounts
         * - `liabilities`: select all liability accounts
         *
         * If no accounts are found, the user's "frontpage accounts" preference will be used. If that is empty, all asset accounts will be used.
         *
         */
        preselected?: 'empty' | 'all' | 'assets' | 'liabilities';
    };
    url: '/v1/chart/account/overview';
};

export type GetChartAccountOverviewErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetChartAccountOverviewError = GetChartAccountOverviewErrors[keyof GetChartAccountOverviewErrors];

export type GetChartAccountOverviewResponses = {
    /**
     * Line chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart.
     */
    200: ChartLine;
};

export type GetChartAccountOverviewResponse = GetChartAccountOverviewResponses[keyof GetChartAccountOverviewResponses];

export type GetChartBalanceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * Optional period to group the data by. If not provided, it will default to '1M' or whatever is deemed relevant for the range provided.
         *
         * If you want to know which periods are available, see the enums or get the configuration value: `GET /api/v1/configuration/firefly.valid_view_ranges`
         *
         */
        period?: '1D' | '1W' | '1M' | '3M' | '6M' | '1Y';
        /**
         * Optional set of preselected accounts to limit the chart to. This may be easier than submitting all asset accounts manually, for example.
         * If you want to know which selection are available, see the enums here or get the configuration value: `GET /api/v1/configuration/firefly.preselected_accounts`
         *
         * - `empty`: do not do a pre-selection
         * - `all`: select all asset and all liability accounts
         * - `assets`: select all asset accounts
         * - `liabilities`: select all liability accounts
         *
         * If no accounts are found, the user's "frontpage accounts" preference will be used. If that is empty, all asset accounts will be used.
         *
         */
        preselected?: 'empty' | 'all' | 'assets' | 'liabilities';
        /**
         * Limit the chart to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         *
         * This list of accounts will be OVERRULED by the `preselected` parameter.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/chart/balance/balance';
};

export type GetChartBalanceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetChartBalanceError = GetChartBalanceErrors[keyof GetChartBalanceErrors];

export type GetChartBalanceResponses = {
    /**
     * Line chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart.
     */
    200: ChartLine;
};

export type GetChartBalanceResponse = GetChartBalanceResponses[keyof GetChartBalanceResponses];

export type GetChartBudgetOverviewData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
    };
    url: '/v1/chart/budget/overview';
};

export type GetChartBudgetOverviewErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetChartBudgetOverviewError = GetChartBudgetOverviewErrors[keyof GetChartBudgetOverviewErrors];

export type GetChartBudgetOverviewResponses = {
    /**
     * Bar chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart.
     */
    200: ChartLine;
};

export type GetChartBudgetOverviewResponse = GetChartBudgetOverviewResponses[keyof GetChartBudgetOverviewResponses];

export type GetChartCategoryOverviewData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
    };
    url: '/v1/chart/category/overview';
};

export type GetChartCategoryOverviewErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetChartCategoryOverviewError = GetChartCategoryOverviewErrors[keyof GetChartCategoryOverviewErrors];

export type GetChartCategoryOverviewResponses = {
    /**
     * Line chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart.
     */
    200: ChartLine;
};

export type GetChartCategoryOverviewResponse = GetChartCategoryOverviewResponses[keyof GetChartCategoryOverviewResponses];

export type BulkUpdateTransactionsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * The JSON query.
         */
        query: string;
    };
    url: '/v1/data/bulk/transactions';
};

export type BulkUpdateTransactionsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type BulkUpdateTransactionsError = BulkUpdateTransactionsErrors[keyof BulkUpdateTransactionsErrors];

export type BulkUpdateTransactionsResponses = {
    /**
     * Empty response when the update was successful. A future improvement is to include the changed transactions.
     */
    204: void;
};

export type BulkUpdateTransactionsResponse = BulkUpdateTransactionsResponses[keyof BulkUpdateTransactionsResponses];

export type DestroyDataData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * The type of data that you wish to destroy. You can only use one at a time.
         */
        objects: DataDestroyObject;
    };
    url: '/v1/data/destroy';
};

export type DestroyDataErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DestroyDataError = DestroyDataErrors[keyof DestroyDataErrors];

export type DestroyDataResponses = {
    /**
     * Empty response when data has been destroyed.
     */
    204: void;
};

export type DestroyDataResponse = DestroyDataResponses[keyof DestroyDataResponses];

export type ExportAccountsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/accounts';
};

export type ExportAccountsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportAccountsError = ExportAccountsErrors[keyof ExportAccountsErrors];

export type ExportAccountsResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportAccountsResponse = ExportAccountsResponses[keyof ExportAccountsResponses];

export type ExportBillsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/bills';
};

export type ExportBillsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportBillsError = ExportBillsErrors[keyof ExportBillsErrors];

export type ExportBillsResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportBillsResponse = ExportBillsResponses[keyof ExportBillsResponses];

export type ExportBudgetsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/budgets';
};

export type ExportBudgetsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportBudgetsError = ExportBudgetsErrors[keyof ExportBudgetsErrors];

export type ExportBudgetsResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportBudgetsResponse = ExportBudgetsResponses[keyof ExportBudgetsResponses];

export type ExportCategoriesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/categories';
};

export type ExportCategoriesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportCategoriesError = ExportCategoriesErrors[keyof ExportCategoriesErrors];

export type ExportCategoriesResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportCategoriesResponse = ExportCategoriesResponses[keyof ExportCategoriesResponses];

export type ExportPiggiesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/piggy-banks';
};

export type ExportPiggiesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportPiggiesError = ExportPiggiesErrors[keyof ExportPiggiesErrors];

export type ExportPiggiesResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportPiggiesResponse = ExportPiggiesResponses[keyof ExportPiggiesResponses];

export type ExportRecurringData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/recurring';
};

export type ExportRecurringErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportRecurringError = ExportRecurringErrors[keyof ExportRecurringErrors];

export type ExportRecurringResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportRecurringResponse = ExportRecurringResponses[keyof ExportRecurringResponses];

export type ExportRulesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/rules';
};

export type ExportRulesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportRulesError = ExportRulesErrors[keyof ExportRulesErrors];

export type ExportRulesResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportRulesResponse = ExportRulesResponses[keyof ExportRulesResponses];

export type ExportTagsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/tags';
};

export type ExportTagsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportTagsError = ExportTagsErrors[keyof ExportTagsErrors];

export type ExportTagsResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportTagsResponse = ExportTagsResponses[keyof ExportTagsResponses];

export type ExportTransactionsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
         *
         */
        accounts?: string;
        /**
         * The file type the export file (CSV is currently the only option).
         */
        type?: ExportFileFilter;
    };
    url: '/v1/data/export/transactions';
};

export type ExportTransactionsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ExportTransactionsError = ExportTransactionsErrors[keyof ExportTransactionsErrors];

export type ExportTransactionsResponses = {
    /**
     * The exported transaction in a file.
     */
    200: Blob | File;
};

export type ExportTransactionsResponse = ExportTransactionsResponses[keyof ExportTransactionsResponses];

export type PurgeDataData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/data/purge';
};

export type PurgeDataErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type PurgeDataError = PurgeDataErrors[keyof PurgeDataErrors];

export type PurgeDataResponses = {
    /**
     * Empty response when data has been purged.
     */
    204: void;
};

export type PurgeDataResponse = PurgeDataResponses[keyof PurgeDataResponses];

export type InsightExpenseExpenseData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you add the accounts ID's of expense accounts, only those accounts
         * are included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID's.
         * Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/expense';
};

export type InsightExpenseExpenseErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseExpenseError = InsightExpenseExpenseErrors[keyof InsightExpenseExpenseErrors];

export type InsightExpenseExpenseResponses = {
    /**
     * A list of expense accounts and expense details. Each expense account has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseExpenseResponse = InsightExpenseExpenseResponses[keyof InsightExpenseExpenseResponses];

export type InsightExpenseAssetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/asset';
};

export type InsightExpenseAssetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseAssetError = InsightExpenseAssetErrors[keyof InsightExpenseAssetErrors];

export type InsightExpenseAssetResponses = {
    /**
     * A list of asset accounts and expense details. Each asset account has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseAssetResponse = InsightExpenseAssetResponses[keyof InsightExpenseAssetResponses];

export type InsightIncomeRevenueData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you add the accounts ID's of revenue accounts, only those accounts
         * are included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID's.
         * Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/revenue';
};

export type InsightIncomeRevenueErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeRevenueError = InsightIncomeRevenueErrors[keyof InsightIncomeRevenueErrors];

export type InsightIncomeRevenueResponses = {
    /**
     * A list of revenue accounts and income details. Each revenue account has one row per currency.
     */
    200: InsightGroup;
};

export type InsightIncomeRevenueResponse = InsightIncomeRevenueResponses[keyof InsightIncomeRevenueResponses];

export type InsightIncomeAssetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/asset';
};

export type InsightIncomeAssetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeAssetError = InsightIncomeAssetErrors[keyof InsightIncomeAssetErrors];

export type InsightIncomeAssetResponses = {
    /**
     * A list of asset accounts and income details. Each asset account has one row per currency.
     */
    200: InsightGroup;
};

export type InsightIncomeAssetResponse = InsightIncomeAssetResponses[keyof InsightIncomeAssetResponses];

export type InsightTransfersData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/asset';
};

export type InsightTransfersErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransfersError = InsightTransfersErrors[keyof InsightTransfersErrors];

export type InsightTransfersResponses = {
    /**
     * A list of asset accounts and transfer details. Each asset account has one row per currency.
     */
    200: InsightTransfer;
};

export type InsightTransfersResponse = InsightTransfersResponses[keyof InsightTransfersResponses];

export type InsightExpenseBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The bills to be included in the results.
         *
         */
        'bills[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/bill';
};

export type InsightExpenseBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseBillError = InsightExpenseBillErrors[keyof InsightExpenseBillErrors];

export type InsightExpenseBillResponses = {
    /**
     * A list of budget and expense details. Each budget has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseBillResponse = InsightExpenseBillResponses[keyof InsightExpenseBillResponses];

export type InsightExpenseNoBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/no-bill';
};

export type InsightExpenseNoBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseNoBillError = InsightExpenseNoBillErrors[keyof InsightExpenseNoBillErrors];

export type InsightExpenseNoBillResponses = {
    /**
     * A list of expense details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightExpenseNoBillResponse = InsightExpenseNoBillResponses[keyof InsightExpenseNoBillResponses];

export type InsightExpenseBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The budgets to be included in the results.
         *
         */
        'budgets[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/budget';
};

export type InsightExpenseBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseBudgetError = InsightExpenseBudgetErrors[keyof InsightExpenseBudgetErrors];

export type InsightExpenseBudgetResponses = {
    /**
     * A list of budget and expense details. Each budget has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseBudgetResponse = InsightExpenseBudgetResponses[keyof InsightExpenseBudgetResponses];

export type InsightExpenseNoBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/no-budget';
};

export type InsightExpenseNoBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseNoBudgetError = InsightExpenseNoBudgetErrors[keyof InsightExpenseNoBudgetErrors];

export type InsightExpenseNoBudgetResponses = {
    /**
     * A list of expense details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightExpenseNoBudgetResponse = InsightExpenseNoBudgetResponses[keyof InsightExpenseNoBudgetResponses];

export type InsightExpenseCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The categories to be included in the results.
         *
         */
        'categories[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/category';
};

export type InsightExpenseCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseCategoryError = InsightExpenseCategoryErrors[keyof InsightExpenseCategoryErrors];

export type InsightExpenseCategoryResponses = {
    /**
     * A list of category and expense details. Each category has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseCategoryResponse = InsightExpenseCategoryResponses[keyof InsightExpenseCategoryResponses];

export type InsightExpenseNoCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/no-category';
};

export type InsightExpenseNoCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseNoCategoryError = InsightExpenseNoCategoryErrors[keyof InsightExpenseNoCategoryErrors];

export type InsightExpenseNoCategoryResponses = {
    /**
     * A list of expense details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightExpenseNoCategoryResponse = InsightExpenseNoCategoryResponses[keyof InsightExpenseNoCategoryResponses];

export type InsightIncomeCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The categories to be included in the results.
         *
         */
        'categories[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/category';
};

export type InsightIncomeCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeCategoryError = InsightIncomeCategoryErrors[keyof InsightIncomeCategoryErrors];

export type InsightIncomeCategoryResponses = {
    /**
     * A list of category and income details. Each category has one row per currency.
     */
    200: InsightGroup;
};

export type InsightIncomeCategoryResponse = InsightIncomeCategoryResponses[keyof InsightIncomeCategoryResponses];

export type InsightIncomeNoCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/no-category';
};

export type InsightIncomeNoCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeNoCategoryError = InsightIncomeNoCategoryErrors[keyof InsightIncomeNoCategoryErrors];

export type InsightIncomeNoCategoryResponses = {
    /**
     * A list of income details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightIncomeNoCategoryResponse = InsightIncomeNoCategoryResponses[keyof InsightIncomeNoCategoryResponses];

export type InsightTransferCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The categories to be included in the results.
         *
         */
        'categories[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/category';
};

export type InsightTransferCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransferCategoryError = InsightTransferCategoryErrors[keyof InsightTransferCategoryErrors];

export type InsightTransferCategoryResponses = {
    /**
     * A list of category and transfer details. Each category has one row per currency.
     */
    200: InsightGroup;
};

export type InsightTransferCategoryResponse = InsightTransferCategoryResponses[keyof InsightTransferCategoryResponses];

export type InsightTransferNoCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/no-category';
};

export type InsightTransferNoCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransferNoCategoryError = InsightTransferNoCategoryErrors[keyof InsightTransferNoCategoryErrors];

export type InsightTransferNoCategoryResponses = {
    /**
     * A list of transfer details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightTransferNoCategoryResponse = InsightTransferNoCategoryResponses[keyof InsightTransferNoCategoryResponses];

export type InsightExpenseTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The tags to be included in the results.
         *
         */
        'tags[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/tag';
};

export type InsightExpenseTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseTagError = InsightExpenseTagErrors[keyof InsightExpenseTagErrors];

export type InsightExpenseTagResponses = {
    /**
     * A list of tag and expense details. Each tag has one row per currency.
     */
    200: InsightGroup;
};

export type InsightExpenseTagResponse = InsightExpenseTagResponses[keyof InsightExpenseTagResponses];

export type InsightExpenseNoTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/no-tag';
};

export type InsightExpenseNoTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseNoTagError = InsightExpenseNoTagErrors[keyof InsightExpenseNoTagErrors];

export type InsightExpenseNoTagResponses = {
    /**
     * A list of expense details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightExpenseNoTagResponse = InsightExpenseNoTagResponses[keyof InsightExpenseNoTagResponses];

export type InsightIncomeTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The tags to be included in the results.
         *
         */
        'tags[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/tag';
};

export type InsightIncomeTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeTagError = InsightIncomeTagErrors[keyof InsightIncomeTagErrors];

export type InsightIncomeTagResponses = {
    /**
     * A list of tag and income details. Each tag has one row per currency.
     */
    200: InsightGroup;
};

export type InsightIncomeTagResponse = InsightIncomeTagResponses[keyof InsightIncomeTagResponses];

export type InsightIncomeNoTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/no-tag';
};

export type InsightIncomeNoTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeNoTagError = InsightIncomeNoTagErrors[keyof InsightIncomeNoTagErrors];

export type InsightIncomeNoTagResponses = {
    /**
     * A list of income details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightIncomeNoTagResponse = InsightIncomeNoTagResponses[keyof InsightIncomeNoTagResponses];

export type InsightTransferTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The tags to be included in the results.
         *
         */
        'tags[]'?: Array<number>;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/tag';
};

export type InsightTransferTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransferTagError = InsightTransferTagErrors[keyof InsightTransferTagErrors];

export type InsightTransferTagResponses = {
    /**
     * A list of tag and transfer details. Each tag has one row per currency.
     */
    200: InsightGroup;
};

export type InsightTransferTagResponse = InsightTransferTagResponses[keyof InsightTransferTagResponses];

export type InsightTransferNoTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/no-tag';
};

export type InsightTransferNoTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransferNoTagError = InsightTransferNoTagErrors[keyof InsightTransferNoTagErrors];

export type InsightTransferNoTagResponses = {
    /**
     * A list of transfer details. One row per currency.
     */
    200: InsightTotal;
};

export type InsightTransferNoTagResponse = InsightTransferNoTagResponses[keyof InsightTransferNoTagResponses];

export type InsightExpenseTotalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/expense/total';
};

export type InsightExpenseTotalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightExpenseTotalError = InsightExpenseTotalErrors[keyof InsightExpenseTotalErrors];

export type InsightExpenseTotalResponses = {
    /**
     * A list of sums in different currencies.
     */
    200: InsightTotal;
};

export type InsightExpenseTotalResponse = InsightExpenseTotalResponses[keyof InsightExpenseTotalResponses];

export type InsightIncomeTotalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/income/total';
};

export type InsightIncomeTotalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightIncomeTotalError = InsightIncomeTotalErrors[keyof InsightIncomeTotalErrors];

export type InsightIncomeTotalResponses = {
    /**
     * A list of sums in different currencies.
     */
    200: InsightTotal;
};

export type InsightIncomeTotalResponse = InsightIncomeTotalResponses[keyof InsightIncomeTotalResponses];

export type InsightTransferTotalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
         * asset accounts / liabilities will be included. Other account ID's will be ignored.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/insight/transfer/total';
};

export type InsightTransferTotalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type InsightTransferTotalError = InsightTransferTotalErrors[keyof InsightTransferTotalErrors];

export type InsightTransferTotalResponses = {
    /**
     * A list of sums in different currencies.
     */
    200: InsightTotal;
};

export type InsightTransferTotalResponse = InsightTransferTotalResponses[keyof InsightTransferTotalResponses];

export type ListTransactionByAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned.
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/accounts/{id}/transactions';
};

export type ListTransactionByAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByAccountError = ListTransactionByAccountErrors[keyof ListTransactionByAccountErrors];

export type ListTransactionByAccountResponses = {
    /**
     * A list of transactions
     */
    200: TransactionArray;
};

export type ListTransactionByAccountResponse = ListTransactionByAccountResponses[keyof ListTransactionByAccountResponses];

export type ListAttachmentByAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/accounts/{id}/attachments';
};

export type ListAttachmentByAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByAccountError = ListAttachmentByAccountErrors[keyof ListAttachmentByAccountErrors];

export type ListAttachmentByAccountResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByAccountResponse = ListAttachmentByAccountResponses[keyof ListAttachmentByAccountResponses];

export type ListPiggyBankByAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/accounts/{id}/piggy-banks';
};

export type ListPiggyBankByAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListPiggyBankByAccountError = ListPiggyBankByAccountErrors[keyof ListPiggyBankByAccountErrors];

export type ListPiggyBankByAccountResponses = {
    /**
     * A list of piggy banks
     */
    200: PiggyBankArray;
};

export type ListPiggyBankByAccountResponse = ListPiggyBankByAccountResponses[keyof ListPiggyBankByAccountResponses];

export type ListAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. May be omitted.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. Must be after "start". Can not be the same as "start". May be omitted.
         *
         */
        end?: string;
        /**
         * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
         *
         */
        date?: string;
        /**
         * Optional filter on the account type(s) returned
         */
        type?: AccountTypeFilter;
    };
    url: '/v1/accounts';
};

export type ListAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAccountError = ListAccountErrors[keyof ListAccountErrors];

export type ListAccountResponses = {
    /**
     * A list of accounts
     */
    200: AccountArray;
};

export type ListAccountResponse = ListAccountResponses[keyof ListAccountResponses];

export type StoreAccountData = {
    /**
     * JSON array with the necessary account information or key=value pairs. See the model for the exact specifications.
     */
    body: AccountStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/accounts';
};

export type StoreAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreAccountError = StoreAccountErrors[keyof StoreAccountErrors];

export type StoreAccountResponses = {
    /**
     * New account stored, result in response.
     */
    200: AccountSingle;
};

export type StoreAccountResponse = StoreAccountResponses[keyof StoreAccountResponses];

export type DeleteAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{id}';
};

export type DeleteAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteAccountError = DeleteAccountErrors[keyof DeleteAccountErrors];

export type DeleteAccountResponses = {
    /**
     * Account deleted
     */
    204: void;
};

export type DeleteAccountResponse = DeleteAccountResponses[keyof DeleteAccountResponses];

export type GetAccountData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD. May be omitted.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. Must be after "start". Can not be the same as "start". May be omitted.
         *
         */
        end?: string;
        /**
         * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
         *
         */
        date?: string;
    };
    url: '/v1/accounts/{id}';
};

export type GetAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetAccountError = GetAccountErrors[keyof GetAccountErrors];

export type GetAccountResponses = {
    /**
     * The requested account
     */
    200: AccountSingle;
};

export type GetAccountResponse = GetAccountResponses[keyof GetAccountResponses];

export type UpdateAccountData = {
    /**
     * JSON array or form-data with updated account information. See the model for the exact specifications.
     */
    body: AccountUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: never;
    url: '/v1/accounts/{id}';
};

export type UpdateAccountErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateAccountError = UpdateAccountErrors[keyof UpdateAccountErrors];

export type UpdateAccountResponses = {
    /**
     * Updated account stored, result in response
     */
    200: AccountSingle;
};

export type UpdateAccountResponse = UpdateAccountResponses[keyof UpdateAccountResponses];

export type ListAttachmentData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/attachments';
};

export type ListAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentError = ListAttachmentErrors[keyof ListAttachmentErrors];

export type ListAttachmentResponses = {
    /**
     * A list of attachments.
     */
    200: AttachmentArray;
};

export type ListAttachmentResponse = ListAttachmentResponses[keyof ListAttachmentResponses];

export type StoreAttachmentData = {
    /**
     * JSON array or key=value pairs with the necessary attachment information. See the model for the exact specifications.
     */
    body: AttachmentStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/attachments';
};

export type StoreAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreAttachmentError = StoreAttachmentErrors[keyof StoreAttachmentErrors];

export type StoreAttachmentResponses = {
    /**
     * New attachment stored, result in response.
     */
    200: AttachmentSingle;
};

export type StoreAttachmentResponse = StoreAttachmentResponses[keyof StoreAttachmentResponses];

export type DeleteAttachmentData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the single attachment.
         */
        id: string;
    };
    query?: never;
    url: '/v1/attachments/{id}';
};

export type DeleteAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteAttachmentError = DeleteAttachmentErrors[keyof DeleteAttachmentErrors];

export type DeleteAttachmentResponses = {
    /**
     * Attachment deleted.
     */
    204: void;
};

export type DeleteAttachmentResponse = DeleteAttachmentResponses[keyof DeleteAttachmentResponses];

export type GetAttachmentData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the attachment.
         */
        id: string;
    };
    query?: never;
    url: '/v1/attachments/{id}';
};

export type GetAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetAttachmentError = GetAttachmentErrors[keyof GetAttachmentErrors];

export type GetAttachmentResponses = {
    /**
     * The requested attachment
     */
    200: AttachmentSingle;
};

export type GetAttachmentResponse = GetAttachmentResponses[keyof GetAttachmentResponses];

export type UpdateAttachmentData = {
    /**
     * JSON array with updated attachment information. See the model for the exact specifications.
     */
    body: AttachmentUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the attachment.
         */
        id: string;
    };
    query?: never;
    url: '/v1/attachments/{id}';
};

export type UpdateAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateAttachmentError = UpdateAttachmentErrors[keyof UpdateAttachmentErrors];

export type UpdateAttachmentResponses = {
    /**
     * Updated attachment stored, result in response
     */
    200: AttachmentSingle;
};

export type UpdateAttachmentResponse = UpdateAttachmentResponses[keyof UpdateAttachmentResponses];

export type DownloadAttachmentData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the attachment.
         */
        id: string;
    };
    query?: never;
    url: '/v1/attachments/{id}/download';
};

export type DownloadAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DownloadAttachmentError = DownloadAttachmentErrors[keyof DownloadAttachmentErrors];

export type DownloadAttachmentResponses = {
    /**
     * The requested attachment
     */
    200: Blob | File;
};

export type DownloadAttachmentResponse = DownloadAttachmentResponses[keyof DownloadAttachmentResponses];

export type UploadAttachmentData = {
    body?: Blob | File;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the attachment.
         */
        id: string;
    };
    query?: never;
    url: '/v1/attachments/{id}/upload';
};

export type UploadAttachmentErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UploadAttachmentError = UploadAttachmentErrors[keyof UploadAttachmentErrors];

export type UploadAttachmentResponses = {
    /**
     * Upload was a success
     */
    204: void;
};

export type UploadAttachmentResponse = UploadAttachmentResponses[keyof UploadAttachmentResponses];

export type ListAvailableBudgetsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
    };
    url: '/v1/available-budgets';
};

export type ListAvailableBudgetsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAvailableBudgetsError = ListAvailableBudgetsErrors[keyof ListAvailableBudgetsErrors];

export type ListAvailableBudgetsResponses = {
    /**
     * A list of available budget amounts.
     */
    200: AvailableBudgetArray;
};

export type ListAvailableBudgetsResponse = ListAvailableBudgetsResponses[keyof ListAvailableBudgetsResponses];

export type GetAvailableBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the available budget.
         */
        id: string;
    };
    query?: never;
    url: '/v1/available-budgets/{id}';
};

export type GetAvailableBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetAvailableBudgetError = GetAvailableBudgetErrors[keyof GetAvailableBudgetErrors];

export type GetAvailableBudgetResponses = {
    /**
     * The requested available budget
     */
    200: AvailableBudgetSingle;
};

export type GetAvailableBudgetResponse = GetAvailableBudgetResponses[keyof GetAvailableBudgetResponses];

export type ListAttachmentByBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/bills/{id}/attachments';
};

export type ListAttachmentByBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByBillError = ListAttachmentByBillErrors[keyof ListAttachmentByBillErrors];

export type ListAttachmentByBillResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByBillResponse = ListAttachmentByBillResponses[keyof ListAttachmentByBillResponses];

export type ListRuleByBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: never;
    url: '/v1/bills/{id}/rules';
};

export type ListRuleByBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRuleByBillError = ListRuleByBillErrors[keyof ListRuleByBillErrors];

export type ListRuleByBillResponses = {
    /**
     * A list of rules
     */
    200: RuleArray;
};

export type ListRuleByBillResponse = ListRuleByBillResponses[keyof ListRuleByBillResponses];

export type ListTransactionByBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/bills/{id}/transactions';
};

export type ListTransactionByBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByBillError = ListTransactionByBillErrors[keyof ListTransactionByBillErrors];

export type ListTransactionByBillResponses = {
    /**
     * A list of transactions
     */
    200: TransactionArray;
};

export type ListTransactionByBillResponse = ListTransactionByBillResponses[keyof ListTransactionByBillResponses];

export type ListBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         *
         */
        end?: string;
    };
    url: '/v1/bills';
};

export type ListBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBillError = ListBillErrors[keyof ListBillErrors];

export type ListBillResponses = {
    /**
     * A list of bills
     */
    200: BillArray;
};

export type ListBillResponse = ListBillResponses[keyof ListBillResponses];

export type StoreBillData = {
    /**
     * JSON array or key=value pairs with the necessary bill information. See the model for the exact specifications.
     */
    body: BillStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/bills';
};

export type StoreBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreBillError = StoreBillErrors[keyof StoreBillErrors];

export type StoreBillResponses = {
    /**
     * New bill stored, result in response.
     */
    200: BillSingle;
};

export type StoreBillResponse = StoreBillResponses[keyof StoreBillResponses];

export type DeleteBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: never;
    url: '/v1/bills/{id}';
};

export type DeleteBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteBillError = DeleteBillErrors[keyof DeleteBillErrors];

export type DeleteBillResponses = {
    /**
     * Bill deleted.
     */
    204: void;
};

export type DeleteBillResponse = DeleteBillResponses[keyof DeleteBillResponses];

export type GetBillData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
         *
         */
        end?: string;
    };
    url: '/v1/bills/{id}';
};

export type GetBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBillError = GetBillErrors[keyof GetBillErrors];

export type GetBillResponses = {
    /**
     * The requested bill
     */
    200: BillSingle;
};

export type GetBillResponse = GetBillResponses[keyof GetBillResponses];

export type UpdateBillData = {
    /**
     * JSON array or key=value pairs with updated bill information. See the model for the exact specifications.
     */
    body: BillUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the bill.
         */
        id: string;
    };
    query?: never;
    url: '/v1/bills/{id}';
};

export type UpdateBillErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateBillError = UpdateBillErrors[keyof UpdateBillErrors];

export type UpdateBillResponses = {
    /**
     * Updated bill stored, result in response
     */
    200: BillSingle;
};

export type UpdateBillResponse = UpdateBillResponses[keyof UpdateBillResponses];

export type ListTransactionByBudgetLimitData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget. The budget limit MUST be associated to the budget ID.
         */
        id: string;
        /**
         * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         */
        limitId: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/budgets/{id}/limits/{limitId}/transactions';
};

export type ListTransactionByBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByBudgetLimitError = ListTransactionByBudgetLimitErrors[keyof ListTransactionByBudgetLimitErrors];

export type ListTransactionByBudgetLimitResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionByBudgetLimitResponse = ListTransactionByBudgetLimitResponses[keyof ListTransactionByBudgetLimitResponses];

export type ListBudgetLimitByBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the requested budget.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
    };
    url: '/v1/budgets/{id}/limits';
};

export type ListBudgetLimitByBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBudgetLimitByBudgetError = ListBudgetLimitByBudgetErrors[keyof ListBudgetLimitByBudgetErrors];

export type ListBudgetLimitByBudgetResponses = {
    /**
     * A list of budget limits applicable to this budget.
     */
    200: BudgetLimitArray;
};

export type ListBudgetLimitByBudgetResponse = ListBudgetLimitByBudgetResponses[keyof ListBudgetLimitByBudgetResponses];

export type StoreBudgetLimitData = {
    /**
     * JSON array or key=value pairs with the necessary budget information. See the model for the exact specifications.
     */
    body: BudgetLimitStoreWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget.
         */
        id: string;
    };
    query?: never;
    url: '/v1/budgets/{id}/limits';
};

export type StoreBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreBudgetLimitError = StoreBudgetLimitErrors[keyof StoreBudgetLimitErrors];

export type StoreBudgetLimitResponses = {
    /**
     * New budget limit stored, result in response.
     */
    200: BudgetLimitSingle;
};

export type StoreBudgetLimitResponse = StoreBudgetLimitResponses[keyof StoreBudgetLimitResponses];

export type DeleteBudgetLimitData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget. The budget limit MUST be associated to the budget ID.
         */
        id: string;
        /**
         * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         */
        limitId: string;
    };
    query?: never;
    url: '/v1/budgets/{id}/limits/{limitId}';
};

export type DeleteBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteBudgetLimitError = DeleteBudgetLimitErrors[keyof DeleteBudgetLimitErrors];

export type DeleteBudgetLimitResponses = {
    /**
     * Budget limit deleted.
     */
    204: void;
};

export type DeleteBudgetLimitResponse = DeleteBudgetLimitResponses[keyof DeleteBudgetLimitResponses];

export type GetBudgetLimitData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget. The budget limit MUST be associated to the budget ID.
         */
        id: string;
        /**
         * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         */
        limitId: number;
    };
    query?: never;
    url: '/v1/budgets/{id}/limits/{limitId}';
};

export type GetBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBudgetLimitError = GetBudgetLimitErrors[keyof GetBudgetLimitErrors];

export type GetBudgetLimitResponses = {
    /**
     * The requested budget limit
     */
    200: BudgetLimitSingle;
};

export type GetBudgetLimitResponse = GetBudgetLimitResponses[keyof GetBudgetLimitResponses];

export type UpdateBudgetLimitData = {
    /**
     * JSON array with updated budget limit information. See the model for the exact specifications.
     */
    body: BudgetLimitUpdateWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget. The budget limit MUST be associated to the budget ID.
         */
        id: string;
        /**
         * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         */
        limitId: string;
    };
    query?: never;
    url: '/v1/budgets/{id}/limits/{limitId}';
};

export type UpdateBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateBudgetLimitError = UpdateBudgetLimitErrors[keyof UpdateBudgetLimitErrors];

export type UpdateBudgetLimitResponses = {
    /**
     * Updated budget limit stored, result in response
     */
    200: BudgetLimitSingle;
};

export type UpdateBudgetLimitResponse = UpdateBudgetLimitResponses[keyof UpdateBudgetLimitResponses];

export type ListBudgetLimitData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
    };
    url: '/v1/budget-limits';
};

export type ListBudgetLimitErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBudgetLimitError = ListBudgetLimitErrors[keyof ListBudgetLimitErrors];

export type ListBudgetLimitResponses = {
    /**
     * A list of budget limits.
     */
    200: BudgetLimitArray;
};

export type ListBudgetLimitResponse = ListBudgetLimitResponses[keyof ListBudgetLimitResponses];

export type ListTransactionByBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/budgets/{id}/transactions';
};

export type ListTransactionByBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByBudgetError = ListTransactionByBudgetErrors[keyof ListTransactionByBudgetErrors];

export type ListTransactionByBudgetResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionByBudgetResponse = ListTransactionByBudgetResponses[keyof ListTransactionByBudgetResponses];

export type ListAttachmentByBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/budgets/{id}/attachments';
};

export type ListAttachmentByBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByBudgetError = ListAttachmentByBudgetErrors[keyof ListAttachmentByBudgetErrors];

export type ListAttachmentByBudgetResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByBudgetResponse = ListAttachmentByBudgetResponses[keyof ListAttachmentByBudgetResponses];

export type ListTransactionWithoutBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end?: string;
    };
    url: '/v1/budgets/transactions-without-budget';
};

export type ListTransactionWithoutBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionWithoutBudgetError = ListTransactionWithoutBudgetErrors[keyof ListTransactionWithoutBudgetErrors];

export type ListTransactionWithoutBudgetResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionWithoutBudgetResponse = ListTransactionWithoutBudgetResponses[keyof ListTransactionWithoutBudgetResponses];

export type ListBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
         *
         */
        end?: string;
    };
    url: '/v1/budgets';
};

export type ListBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBudgetError = ListBudgetErrors[keyof ListBudgetErrors];

export type ListBudgetResponses = {
    /**
     * A list of budgets.
     */
    200: BudgetArray;
};

export type ListBudgetResponse = ListBudgetResponses[keyof ListBudgetResponses];

export type StoreBudgetData = {
    /**
     * JSON array or key=value pairs with the necessary budget information. See the model for the exact specifications.
     */
    body: BudgetStoreWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/budgets';
};

export type StoreBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreBudgetError = StoreBudgetErrors[keyof StoreBudgetErrors];

export type StoreBudgetResponses = {
    /**
     * New budget stored, result in response.
     */
    200: BudgetSingle;
};

export type StoreBudgetResponse = StoreBudgetResponses[keyof StoreBudgetResponses];

export type DeleteBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget.
         */
        id: string;
    };
    query?: never;
    url: '/v1/budgets/{id}';
};

export type DeleteBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteBudgetError = DeleteBudgetErrors[keyof DeleteBudgetErrors];

export type DeleteBudgetResponses = {
    /**
     * Budget deleted.
     */
    204: void;
};

export type DeleteBudgetResponse = DeleteBudgetResponses[keyof DeleteBudgetResponses];

export type GetBudgetData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the requested budget.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to get info on how much the user has spent.
         *
         */
        end?: string;
    };
    url: '/v1/budgets/{id}';
};

export type GetBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBudgetError = GetBudgetErrors[keyof GetBudgetErrors];

export type GetBudgetResponses = {
    /**
     * The requested budget
     */
    200: BudgetSingle;
};

export type GetBudgetResponse = GetBudgetResponses[keyof GetBudgetResponses];

export type UpdateBudgetData = {
    /**
     * JSON array with updated budget information. See the model for the exact specifications.
     */
    body: BudgetUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the budget.
         */
        id: string;
    };
    query?: never;
    url: '/v1/budgets/{id}';
};

export type UpdateBudgetErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateBudgetError = UpdateBudgetErrors[keyof UpdateBudgetErrors];

export type UpdateBudgetResponses = {
    /**
     * Updated budget stored, result in response
     */
    200: BudgetSingle;
};

export type UpdateBudgetResponse = UpdateBudgetResponses[keyof UpdateBudgetResponses];

export type ListTransactionByCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the category.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD, to limit the result list.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the result list.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/categories/{id}/transactions';
};

export type ListTransactionByCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByCategoryError = ListTransactionByCategoryErrors[keyof ListTransactionByCategoryErrors];

export type ListTransactionByCategoryResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionByCategoryResponse = ListTransactionByCategoryResponses[keyof ListTransactionByCategoryResponses];

export type ListAttachmentByCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the category.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/categories/{id}/attachments';
};

export type ListAttachmentByCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByCategoryError = ListAttachmentByCategoryErrors[keyof ListAttachmentByCategoryErrors];

export type ListAttachmentByCategoryResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByCategoryResponse = ListAttachmentByCategoryResponses[keyof ListAttachmentByCategoryResponses];

export type ListCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/categories';
};

export type ListCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListCategoryError = ListCategoryErrors[keyof ListCategoryErrors];

export type ListCategoryResponses = {
    /**
     * A list of categories.
     */
    200: CategoryArray;
};

export type ListCategoryResponse = ListCategoryResponses[keyof ListCategoryResponses];

export type StoreCategoryData = {
    /**
     * JSON array or key=value pairs with the necessary category information. See the model for the exact specifications.
     */
    body: CategoryStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/categories';
};

export type StoreCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreCategoryError = StoreCategoryErrors[keyof StoreCategoryErrors];

export type StoreCategoryResponses = {
    /**
     * New category stored, result in response.
     */
    200: CategorySingle;
};

export type StoreCategoryResponse = StoreCategoryResponses[keyof StoreCategoryResponses];

export type DeleteCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the category.
         */
        id: string;
    };
    query?: never;
    url: '/v1/categories/{id}';
};

export type DeleteCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteCategoryError = DeleteCategoryErrors[keyof DeleteCategoryErrors];

export type DeleteCategoryResponses = {
    /**
     * Category deleted.
     */
    204: void;
};

export type DeleteCategoryResponse = DeleteCategoryResponses[keyof DeleteCategoryResponses];

export type GetCategoryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the category.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD, to show spent and earned info.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to show spent and earned info.
         *
         */
        end?: string;
    };
    url: '/v1/categories/{id}';
};

export type GetCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCategoryError = GetCategoryErrors[keyof GetCategoryErrors];

export type GetCategoryResponses = {
    /**
     * The requested category
     */
    200: CategorySingle;
};

export type GetCategoryResponse = GetCategoryResponses[keyof GetCategoryResponses];

export type UpdateCategoryData = {
    /**
     * JSON array with updated category information. See the model for the exact specifications.
     */
    body: CategoryUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the category.
         */
        id: string;
    };
    query?: never;
    url: '/v1/categories/{id}';
};

export type UpdateCategoryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateCategoryError = UpdateCategoryErrors[keyof UpdateCategoryErrors];

export type UpdateCategoryResponses = {
    /**
     * Updated category stored, result in response
     */
    200: CategorySingle;
};

export type UpdateCategoryResponse = UpdateCategoryResponses[keyof UpdateCategoryResponses];

export type ListCurrencyExchangeRatesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/exchange-rates';
};

export type ListCurrencyExchangeRatesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListCurrencyExchangeRatesError = ListCurrencyExchangeRatesErrors[keyof ListCurrencyExchangeRatesErrors];

export type ListCurrencyExchangeRatesResponses = {
    /**
     * A list of all available currency exchange rates.
     */
    200: CurrencyExchangeRateArray;
};

export type ListCurrencyExchangeRatesResponse = ListCurrencyExchangeRatesResponses[keyof ListCurrencyExchangeRatesResponses];

export type StoreCurrencyExchangeRateData = {
    /**
     * JSON array or key=value pairs with the necessary exchange rate information. See the model for the exact specifications.
     */
    body: CurrencyExchangeRateStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/exchange-rates';
};

export type StoreCurrencyExchangeRateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreCurrencyExchangeRateError = StoreCurrencyExchangeRateErrors[keyof StoreCurrencyExchangeRateErrors];

export type StoreCurrencyExchangeRateResponses = {
    /**
     * New exchange stored, result in response. If a rate already exists for this currency pair and date, it will be updated.
     */
    200: CurrencyExchangeRateSingle;
};

export type StoreCurrencyExchangeRateResponse = StoreCurrencyExchangeRateResponses[keyof StoreCurrencyExchangeRateResponses];

export type DeleteSpecificCurrencyExchangeRateData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the requested currency exchange rate.
         */
        id: string;
    };
    query?: never;
    url: '/v1/exchange-rates/{id}';
};

export type DeleteSpecificCurrencyExchangeRateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteSpecificCurrencyExchangeRateError = DeleteSpecificCurrencyExchangeRateErrors[keyof DeleteSpecificCurrencyExchangeRateErrors];

export type DeleteSpecificCurrencyExchangeRateResponses = {
    /**
     * Currency exchange rate deleted.
     */
    204: void;
};

export type DeleteSpecificCurrencyExchangeRateResponse = DeleteSpecificCurrencyExchangeRateResponses[keyof DeleteSpecificCurrencyExchangeRateResponses];

export type ListSpecificCurrencyExchangeRateData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the requested currency exchange rate.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/exchange-rates/{id}';
};

export type ListSpecificCurrencyExchangeRateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListSpecificCurrencyExchangeRateError = ListSpecificCurrencyExchangeRateErrors[keyof ListSpecificCurrencyExchangeRateErrors];

export type ListSpecificCurrencyExchangeRateResponses = {
    /**
     * The exchange rate requested.
     */
    200: CurrencyExchangeRateSingle;
};

export type ListSpecificCurrencyExchangeRateResponse = ListSpecificCurrencyExchangeRateResponses[keyof ListSpecificCurrencyExchangeRateResponses];

export type UpdateCurrencyExchangeRateData = {
    /**
     * JSON array or form-data with updated exchange rate information. See the model for the exact specifications.
     */
    body: CurrencyExchangeRateUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the currency exchange rate.
         */
        id: string;
    };
    query?: never;
    url: '/v1/exchange-rates/{id}';
};

export type UpdateCurrencyExchangeRateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
};

export type UpdateCurrencyExchangeRateError = UpdateCurrencyExchangeRateErrors[keyof UpdateCurrencyExchangeRateErrors];

export type UpdateCurrencyExchangeRateResponses = {
    /**
     * Updated exchange rate stored, result in response
     */
    200: CurrencyExchangeRateSingle;
};

export type UpdateCurrencyExchangeRateResponse = UpdateCurrencyExchangeRateResponses[keyof UpdateCurrencyExchangeRateResponses];

export type DeleteSpecificCurrencyExchangeRatesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
    };
    query?: never;
    url: '/v1/exchange-rates/{from}/{to}';
};

export type DeleteSpecificCurrencyExchangeRatesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteSpecificCurrencyExchangeRatesError = DeleteSpecificCurrencyExchangeRatesErrors[keyof DeleteSpecificCurrencyExchangeRatesErrors];

export type DeleteSpecificCurrencyExchangeRatesResponses = {
    /**
     * Currency exchange rate(s) deleted.
     */
    204: void;
};

export type DeleteSpecificCurrencyExchangeRatesResponse = DeleteSpecificCurrencyExchangeRatesResponses[keyof DeleteSpecificCurrencyExchangeRatesResponses];

export type ListSpecificCurrencyExchangeRatesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/exchange-rates/{from}/{to}';
};

export type ListSpecificCurrencyExchangeRatesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListSpecificCurrencyExchangeRatesError = ListSpecificCurrencyExchangeRatesErrors[keyof ListSpecificCurrencyExchangeRatesErrors];

export type ListSpecificCurrencyExchangeRatesResponses = {
    /**
     * A list of currency exchange rates.
     */
    200: CurrencyExchangeRateArray;
};

export type ListSpecificCurrencyExchangeRatesResponse = ListSpecificCurrencyExchangeRatesResponses[keyof ListSpecificCurrencyExchangeRatesResponses];

export type DeleteSpecificCurrencyExchangeRateOnDateData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
        date: string;
    };
    query?: never;
    url: '/v1/exchange-rates/{from}/{to}/{date}';
};

export type DeleteSpecificCurrencyExchangeRateOnDateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteSpecificCurrencyExchangeRateOnDateError = DeleteSpecificCurrencyExchangeRateOnDateErrors[keyof DeleteSpecificCurrencyExchangeRateOnDateErrors];

export type DeleteSpecificCurrencyExchangeRateOnDateResponses = {
    /**
     * Currency exchange rate(s) deleted.
     */
    204: void;
};

export type DeleteSpecificCurrencyExchangeRateOnDateResponse = DeleteSpecificCurrencyExchangeRateOnDateResponses[keyof DeleteSpecificCurrencyExchangeRateOnDateResponses];

export type ListSpecificCurrencyExchangeRateOnDateData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
        date: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/exchange-rates/{from}/{to}/{date}';
};

export type ListSpecificCurrencyExchangeRateOnDateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListSpecificCurrencyExchangeRateOnDateError = ListSpecificCurrencyExchangeRateOnDateErrors[keyof ListSpecificCurrencyExchangeRateOnDateErrors];

export type ListSpecificCurrencyExchangeRateOnDateResponses = {
    /**
     * A list of currency exchange rates.
     */
    200: CurrencyExchangeRateArray;
};

export type ListSpecificCurrencyExchangeRateOnDateResponse = ListSpecificCurrencyExchangeRateOnDateResponses[keyof ListSpecificCurrencyExchangeRateOnDateResponses];

export type UpdateCurrencyExchangeRateByDateData = {
    /**
     * JSON array or form-data with updated exchange rate information. See the model for the exact specifications.
     */
    body: CurrencyExchangeRateUpdateNoDate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
        date: string;
    };
    query?: never;
    url: '/v1/exchange-rates/{from}/{to}/{date}';
};

export type UpdateCurrencyExchangeRateByDateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
};

export type UpdateCurrencyExchangeRateByDateError = UpdateCurrencyExchangeRateByDateErrors[keyof UpdateCurrencyExchangeRateByDateErrors];

export type UpdateCurrencyExchangeRateByDateResponses = {
    /**
     * Updated exchange rate stored, result in response
     */
    200: CurrencyExchangeRateSingle;
};

export type UpdateCurrencyExchangeRateByDateResponse = UpdateCurrencyExchangeRateByDateResponses[keyof UpdateCurrencyExchangeRateByDateResponses];

export type StoreCurrencyExchangeRatesByDateData = {
    /**
     * JSON array with the necessary currency exchange rate information. See the model for the exact specifications.
     */
    body: CurrencyExchangeRateStoreByDate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        date: string;
    };
    query?: never;
    url: '/v1/exchange-rates/by-date/{date}';
};

export type StoreCurrencyExchangeRatesByDateErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreCurrencyExchangeRatesByDateError = StoreCurrencyExchangeRatesByDateErrors[keyof StoreCurrencyExchangeRatesByDateErrors];

export type StoreCurrencyExchangeRatesByDateResponses = {
    /**
     * New exchange rates stored, result in response. If a rate already existed for any submitted entry, it will be updated.
     */
    200: CurrencyExchangeRateArray;
};

export type StoreCurrencyExchangeRatesByDateResponse = StoreCurrencyExchangeRatesByDateResponses[keyof StoreCurrencyExchangeRatesByDateResponses];

export type StoreCurrencyExchangeRatesByPairData = {
    /**
     * JSON array with the necessary currency exchange rate information. See the model for the exact specifications.
     */
    body: CurrencyExchangeRateStoreByPair;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code of the 'from' currency.
         */
        from: string;
        /**
         * The currency code of the 'to' currency.
         */
        to: string;
    };
    query?: never;
    url: '/v1/exchange-rates/by-currencies/{from}/{to}';
};

export type StoreCurrencyExchangeRatesByPairErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreCurrencyExchangeRatesByPairError = StoreCurrencyExchangeRatesByPairErrors[keyof StoreCurrencyExchangeRatesByPairErrors];

export type StoreCurrencyExchangeRatesByPairResponses = {
    /**
     * New exchange rates stored, result in response. If a rate already existed for any submitted entry, it will be updated.
     */
    200: CurrencyExchangeRateArray;
};

export type StoreCurrencyExchangeRatesByPairResponse = StoreCurrencyExchangeRatesByPairResponses[keyof StoreCurrencyExchangeRatesByPairResponses];

export type ListTransactionByLinkTypeData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the link type.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD, to limit the results.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the results.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned.
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/link-types/{id}/transactions';
};

export type ListTransactionByLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByLinkTypeError = ListTransactionByLinkTypeErrors[keyof ListTransactionByLinkTypeErrors];

export type ListTransactionByLinkTypeResponses = {
    /**
     * A list of transactions
     */
    200: TransactionArray;
};

export type ListTransactionByLinkTypeResponse = ListTransactionByLinkTypeResponses[keyof ListTransactionByLinkTypeResponses];

export type ListLinkTypeData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/link-types';
};

export type ListLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListLinkTypeError = ListLinkTypeErrors[keyof ListLinkTypeErrors];

export type ListLinkTypeResponses = {
    /**
     * A list of link types.
     */
    200: LinkTypeArray;
};

export type ListLinkTypeResponse = ListLinkTypeResponses[keyof ListLinkTypeResponses];

export type StoreLinkTypeData = {
    /**
     * JSON array with the necessary link type information or key=value pairs. See the model for the exact specifications.
     */
    body: LinkTypeWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/link-types';
};

export type StoreLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreLinkTypeError = StoreLinkTypeErrors[keyof StoreLinkTypeErrors];

export type StoreLinkTypeResponses = {
    /**
     * New link type stored, result in response.
     */
    200: LinkTypeSingle;
};

export type StoreLinkTypeResponse = StoreLinkTypeResponses[keyof StoreLinkTypeResponses];

export type DeleteLinkTypeData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the link type.
         */
        id: string;
    };
    query?: never;
    url: '/v1/link-types/{id}';
};

export type DeleteLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteLinkTypeError = DeleteLinkTypeErrors[keyof DeleteLinkTypeErrors];

export type DeleteLinkTypeResponses = {
    /**
     * Link type deleted
     */
    204: void;
};

export type DeleteLinkTypeResponse = DeleteLinkTypeResponses[keyof DeleteLinkTypeResponses];

export type GetLinkTypeData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the link type.
         */
        id: string;
    };
    query?: never;
    url: '/v1/link-types/{id}';
};

export type GetLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetLinkTypeError = GetLinkTypeErrors[keyof GetLinkTypeErrors];

export type GetLinkTypeResponses = {
    /**
     * The requested link type
     */
    200: LinkTypeSingle;
};

export type GetLinkTypeResponse = GetLinkTypeResponses[keyof GetLinkTypeResponses];

export type UpdateLinkTypeData = {
    /**
     * JSON array or form-data with updated link type information. See the model for the exact specifications.
     */
    body: LinkTypeUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the link type.
         */
        id: string;
    };
    query?: never;
    url: '/v1/link-types/{id}';
};

export type UpdateLinkTypeErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateLinkTypeError = UpdateLinkTypeErrors[keyof UpdateLinkTypeErrors];

export type UpdateLinkTypeResponses = {
    /**
     * Updated link type stored, result in response
     */
    200: LinkTypeSingle;
};

export type UpdateLinkTypeResponse = UpdateLinkTypeResponses[keyof UpdateLinkTypeResponses];

export type ListTransactionLinkData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/transaction-links';
};

export type ListTransactionLinkErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionLinkError = ListTransactionLinkErrors[keyof ListTransactionLinkErrors];

export type ListTransactionLinkResponses = {
    /**
     * A list of transaction links
     */
    200: TransactionLinkArray;
};

export type ListTransactionLinkResponse = ListTransactionLinkResponses[keyof ListTransactionLinkResponses];

export type StoreTransactionLinkData = {
    /**
     * JSON array with the necessary link type information or key=value pairs. See the model for the exact specifications.
     */
    body: TransactionLinkStoreWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/transaction-links';
};

export type StoreTransactionLinkErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreTransactionLinkError = StoreTransactionLinkErrors[keyof StoreTransactionLinkErrors];

export type StoreTransactionLinkResponses = {
    /**
     * New transaction link stored, result in response.
     */
    200: TransactionLinkSingle;
};

export type StoreTransactionLinkResponse = StoreTransactionLinkResponses[keyof StoreTransactionLinkResponses];

export type DeleteTransactionLinkData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction link.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transaction-links/{id}';
};

export type DeleteTransactionLinkErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteTransactionLinkError = DeleteTransactionLinkErrors[keyof DeleteTransactionLinkErrors];

export type DeleteTransactionLinkResponses = {
    /**
     * Transaction link deleted
     */
    204: void;
};

export type DeleteTransactionLinkResponse = DeleteTransactionLinkResponses[keyof DeleteTransactionLinkResponses];

export type GetTransactionLinkData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction link.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transaction-links/{id}';
};

export type GetTransactionLinkErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionLinkError = GetTransactionLinkErrors[keyof GetTransactionLinkErrors];

export type GetTransactionLinkResponses = {
    /**
     * The requested link
     */
    200: TransactionLinkSingle;
};

export type GetTransactionLinkResponse = GetTransactionLinkResponses[keyof GetTransactionLinkResponses];

export type UpdateTransactionLinkData = {
    /**
     * JSON array or form-data with updated link type information. See the model for the exact specifications.
     */
    body: TransactionLinkUpdateWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction link.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transaction-links/{id}';
};

export type UpdateTransactionLinkErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateTransactionLinkError = UpdateTransactionLinkErrors[keyof UpdateTransactionLinkErrors];

export type UpdateTransactionLinkResponses = {
    /**
     * Updated link type stored, result in response
     */
    200: TransactionLinkSingle;
};

export type UpdateTransactionLinkResponse = UpdateTransactionLinkResponses[keyof UpdateTransactionLinkResponses];

export type ListPiggyBankByObjectGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/object-groups/{id}/piggy-banks';
};

export type ListPiggyBankByObjectGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListPiggyBankByObjectGroupError = ListPiggyBankByObjectGroupErrors[keyof ListPiggyBankByObjectGroupErrors];

export type ListPiggyBankByObjectGroupResponses = {
    /**
     * A list of piggy banks
     */
    200: PiggyBankArray;
};

export type ListPiggyBankByObjectGroupResponse = ListPiggyBankByObjectGroupResponses[keyof ListPiggyBankByObjectGroupResponses];

export type ListBillByObjectGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/object-groups/{id}/bills';
};

export type ListBillByObjectGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBillByObjectGroupError = ListBillByObjectGroupErrors[keyof ListBillByObjectGroupErrors];

export type ListBillByObjectGroupResponses = {
    /**
     * A list of bills.
     */
    200: BillArray;
};

export type ListBillByObjectGroupResponse = ListBillByObjectGroupResponses[keyof ListBillByObjectGroupResponses];

export type ListObjectGroupsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/object-groups';
};

export type ListObjectGroupsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListObjectGroupsError = ListObjectGroupsErrors[keyof ListObjectGroupsErrors];

export type ListObjectGroupsResponses = {
    /**
     * A list of object groups
     */
    200: ObjectGroupArray;
};

export type ListObjectGroupsResponse = ListObjectGroupsResponses[keyof ListObjectGroupsResponses];

export type DeleteObjectGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the object group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/object-groups/{id}';
};

export type DeleteObjectGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteObjectGroupError = DeleteObjectGroupErrors[keyof DeleteObjectGroupErrors];

export type DeleteObjectGroupResponses = {
    /**
     * Object group deleted.
     */
    204: void;
};

export type DeleteObjectGroupResponse = DeleteObjectGroupResponses[keyof DeleteObjectGroupResponses];

export type GetObjectGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the object group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/object-groups/{id}';
};

export type GetObjectGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetObjectGroupError = GetObjectGroupErrors[keyof GetObjectGroupErrors];

export type GetObjectGroupResponses = {
    /**
     * The requested object group
     */
    200: ObjectGroupSingle;
};

export type GetObjectGroupResponse = GetObjectGroupResponses[keyof GetObjectGroupResponses];

export type UpdateObjectGroupData = {
    /**
     * JSON array with updated piggy bank information. See the model for the exact specifications.
     */
    body: ObjectGroupUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the object group
         */
        id: string;
    };
    query?: never;
    url: '/v1/object-groups/{id}';
};

export type UpdateObjectGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateObjectGroupError = UpdateObjectGroupErrors[keyof UpdateObjectGroupErrors];

export type UpdateObjectGroupResponses = {
    /**
     * Updated object group stored, result in response
     */
    200: ObjectGroupSingle;
};

export type UpdateObjectGroupResponse = UpdateObjectGroupResponses[keyof UpdateObjectGroupResponses];

export type ListEventByPiggyBankData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the piggy bank
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/piggy-banks/{id}/events';
};

export type ListEventByPiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListEventByPiggyBankError = ListEventByPiggyBankErrors[keyof ListEventByPiggyBankErrors];

export type ListEventByPiggyBankResponses = {
    /**
     * A list of piggy bank related events
     */
    200: PiggyBankEventArray;
};

export type ListEventByPiggyBankResponse = ListEventByPiggyBankResponses[keyof ListEventByPiggyBankResponses];

export type ListAttachmentByPiggyBankData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the piggy bank.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/piggy-banks/{id}/attachments';
};

export type ListAttachmentByPiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByPiggyBankError = ListAttachmentByPiggyBankErrors[keyof ListAttachmentByPiggyBankErrors];

export type ListAttachmentByPiggyBankResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByPiggyBankResponse = ListAttachmentByPiggyBankResponses[keyof ListAttachmentByPiggyBankResponses];

export type ListPiggyBankData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/piggy-banks';
};

export type ListPiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListPiggyBankError = ListPiggyBankErrors[keyof ListPiggyBankErrors];

export type ListPiggyBankResponses = {
    /**
     * A list of piggy banks
     */
    200: PiggyBankArray;
};

export type ListPiggyBankResponse = ListPiggyBankResponses[keyof ListPiggyBankResponses];

export type StorePiggyBankData = {
    /**
     * JSON array or key=value pairs with the necessary piggy bank information. See the model for the exact specifications.
     */
    body: PiggyBankStoreWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/piggy-banks';
};

export type StorePiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StorePiggyBankError = StorePiggyBankErrors[keyof StorePiggyBankErrors];

export type StorePiggyBankResponses = {
    /**
     * New piggy bank stored, result in response.
     */
    200: PiggyBankSingle;
};

export type StorePiggyBankResponse = StorePiggyBankResponses[keyof StorePiggyBankResponses];

export type DeletePiggyBankData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the piggy bank.
         */
        id: string;
    };
    query?: never;
    url: '/v1/piggy-banks/{id}';
};

export type DeletePiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeletePiggyBankError = DeletePiggyBankErrors[keyof DeletePiggyBankErrors];

export type DeletePiggyBankResponses = {
    /**
     * Piggy bank deleted.
     */
    204: void;
};

export type DeletePiggyBankResponse = DeletePiggyBankResponses[keyof DeletePiggyBankResponses];

export type GetPiggyBankData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the piggy bank.
         */
        id: string;
    };
    query?: never;
    url: '/v1/piggy-banks/{id}';
};

export type GetPiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetPiggyBankError = GetPiggyBankErrors[keyof GetPiggyBankErrors];

export type GetPiggyBankResponses = {
    /**
     * The requested piggy bank
     */
    200: PiggyBankSingle;
};

export type GetPiggyBankResponse = GetPiggyBankResponses[keyof GetPiggyBankResponses];

export type UpdatePiggyBankData = {
    /**
     * JSON array with updated piggy bank information. See the model for the exact specifications.
     */
    body: PiggyBankUpdateWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the piggy bank
         */
        id: string;
    };
    query?: never;
    url: '/v1/piggy-banks/{id}';
};

export type UpdatePiggyBankErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdatePiggyBankError = UpdatePiggyBankErrors[keyof UpdatePiggyBankErrors];

export type UpdatePiggyBankResponses = {
    /**
     * Updated piggy bank stored, result in response
     */
    200: PiggyBankSingle;
};

export type UpdatePiggyBankResponse = UpdatePiggyBankResponses[keyof UpdatePiggyBankResponses];

export type ListTransactionByRecurrenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the recurring transaction.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. Both the start and end date must be present.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. Both the start and end date must be present.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/recurrences/{id}/transactions';
};

export type ListTransactionByRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByRecurrenceError = ListTransactionByRecurrenceErrors[keyof ListTransactionByRecurrenceErrors];

export type ListTransactionByRecurrenceResponses = {
    /**
     * A list of transactions
     */
    200: TransactionArray;
};

export type ListTransactionByRecurrenceResponse = ListTransactionByRecurrenceResponses[keyof ListTransactionByRecurrenceResponses];

export type ListRecurrenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/recurrences';
};

export type ListRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRecurrenceError = ListRecurrenceErrors[keyof ListRecurrenceErrors];

export type ListRecurrenceResponses = {
    /**
     * A list of recurring transactions.
     */
    200: RecurrenceArray;
};

export type ListRecurrenceResponse = ListRecurrenceResponses[keyof ListRecurrenceResponses];

export type StoreRecurrenceData = {
    /**
     * JSON array or key=value pairs with the necessary recurring transaction information. See the model for the exact specifications.
     */
    body: RecurrenceStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/recurrences';
};

export type StoreRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreRecurrenceError = StoreRecurrenceErrors[keyof StoreRecurrenceErrors];

export type StoreRecurrenceResponses = {
    /**
     * New recurring transaction stored, result in response.
     */
    200: RecurrenceSingle;
};

export type StoreRecurrenceResponse = StoreRecurrenceResponses[keyof StoreRecurrenceResponses];

export type DeleteRecurrenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the recurring transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/recurrences/{id}';
};

export type DeleteRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteRecurrenceError = DeleteRecurrenceErrors[keyof DeleteRecurrenceErrors];

export type DeleteRecurrenceResponses = {
    /**
     * Recurring transaction deleted.
     */
    204: void;
};

export type DeleteRecurrenceResponse = DeleteRecurrenceResponses[keyof DeleteRecurrenceResponses];

export type GetRecurrenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the recurring transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/recurrences/{id}';
};

export type GetRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRecurrenceError = GetRecurrenceErrors[keyof GetRecurrenceErrors];

export type GetRecurrenceResponses = {
    /**
     * The requested recurring transaction
     */
    200: RecurrenceSingle;
};

export type GetRecurrenceResponse = GetRecurrenceResponses[keyof GetRecurrenceResponses];

export type UpdateRecurrenceData = {
    /**
     * JSON array with updated recurring transaction information. See the model for the exact specifications.
     */
    body: RecurrenceUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the recurring transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/recurrences/{id}';
};

export type UpdateRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateRecurrenceError = UpdateRecurrenceErrors[keyof UpdateRecurrenceErrors];

export type UpdateRecurrenceResponses = {
    /**
     * Updated recurring transaction stored, result in response
     */
    200: RecurrenceSingle;
};

export type UpdateRecurrenceResponse = UpdateRecurrenceResponses[keyof UpdateRecurrenceResponses];

export type TriggerRecurrenceRecurrenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the recurring transaction.
         */
        id: string;
    };
    query: {
        /**
         * A date formatted YYYY-MM-DD. This is the date for which you want the recurrence to fire. You can take the date from the list of occurrences in the recurring transaction.
         *
         */
        date: string;
    };
    url: '/v1/recurrences/{id}/trigger';
};

export type TriggerRecurrenceRecurrenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type TriggerRecurrenceRecurrenceError = TriggerRecurrenceRecurrenceErrors[keyof TriggerRecurrenceRecurrenceErrors];

export type TriggerRecurrenceRecurrenceResponses = {
    /**
     * A list of transactions (always just 1) created by the recurrence, or a list of zero (0) when there is nothing to create for this date.
     */
    200: TransactionArray;
};

export type TriggerRecurrenceRecurrenceResponse = TriggerRecurrenceRecurrenceResponses[keyof TriggerRecurrenceRecurrenceResponses];

export type ListRuleByGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/rule-groups/{id}/rules';
};

export type ListRuleByGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRuleByGroupError = ListRuleByGroupErrors[keyof ListRuleByGroupErrors];

export type ListRuleByGroupResponses = {
    /**
     * A list of rules.
     */
    200: RuleArray;
};

export type ListRuleByGroupResponse = ListRuleByGroupResponses[keyof ListRuleByGroupResponses];

export type TestRuleGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         *
         */
        end?: string;
        /**
         * Maximum number of transactions Firefly III will try. Don't set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
         *
         */
        search_limit?: number;
        /**
         * Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don't go above the user's page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
         *
         */
        triggered_limit?: number;
        /**
         * Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/rule-groups/{id}/test';
};

export type TestRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type TestRuleGroupError = TestRuleGroupErrors[keyof TestRuleGroupErrors];

export type TestRuleGroupResponses = {
    /**
     * A list of transactions that would be changed by any of the rules of the rule group. No changes will be made.
     */
    200: TransactionArray;
};

export type TestRuleGroupResponse = TestRuleGroupResponses[keyof TestRuleGroupResponses];

export type FireRuleGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
         *
         */
        end?: string;
        /**
         * Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/rule-groups/{id}/trigger';
};

export type FireRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type FireRuleGroupError = FireRuleGroupErrors[keyof FireRuleGroupErrors];

export type FireRuleGroupResponses = {
    /**
     * The rules in the group are executed. Due to the setup of this function (asynchronous job execution) the result cannot be displayed.
     */
    204: void;
};

export type FireRuleGroupResponse = FireRuleGroupResponses[keyof FireRuleGroupResponses];

export type ListRuleGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/rule-groups';
};

export type ListRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRuleGroupError = ListRuleGroupErrors[keyof ListRuleGroupErrors];

export type ListRuleGroupResponses = {
    /**
     * A list of rule groups.
     */
    200: RuleGroupArray;
};

export type ListRuleGroupResponse = ListRuleGroupResponses[keyof ListRuleGroupResponses];

export type StoreRuleGroupData = {
    /**
     * JSON array or key=value pairs with the necessary rule group information. See the model for the exact specifications.
     */
    body: RuleGroupStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/rule-groups';
};

export type StoreRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreRuleGroupError = StoreRuleGroupErrors[keyof StoreRuleGroupErrors];

export type StoreRuleGroupResponses = {
    /**
     * New rule group stored, result in response.
     */
    200: RuleGroupSingle;
};

export type StoreRuleGroupResponse = StoreRuleGroupResponses[keyof StoreRuleGroupResponses];

export type DeleteRuleGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rule-groups/{id}';
};

export type DeleteRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteRuleGroupError = DeleteRuleGroupErrors[keyof DeleteRuleGroupErrors];

export type DeleteRuleGroupResponses = {
    /**
     * Rule group deleted.
     */
    204: void;
};

export type DeleteRuleGroupResponse = DeleteRuleGroupResponses[keyof DeleteRuleGroupResponses];

export type GetRuleGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rule-groups/{id}';
};

export type GetRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRuleGroupError = GetRuleGroupErrors[keyof GetRuleGroupErrors];

export type GetRuleGroupResponses = {
    /**
     * The requested rule group
     */
    200: RuleGroupSingle;
};

export type GetRuleGroupResponse = GetRuleGroupResponses[keyof GetRuleGroupResponses];

export type UpdateRuleGroupData = {
    /**
     * JSON array with updated rule group information. See the model for the exact specifications.
     */
    body: RuleGroupUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rule-groups/{id}';
};

export type UpdateRuleGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateRuleGroupError = UpdateRuleGroupErrors[keyof UpdateRuleGroupErrors];

export type UpdateRuleGroupResponses = {
    /**
     * Updated rule group stored, result in response
     */
    200: RuleGroupSingle;
};

export type UpdateRuleGroupResponse = UpdateRuleGroupResponses[keyof UpdateRuleGroupResponses];

export type TestRuleData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
         *
         */
        end?: string;
        /**
         * Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/rules/{id}/test';
};

export type TestRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type TestRuleError = TestRuleErrors[keyof TestRuleErrors];

export type TestRuleResponses = {
    /**
     * A list of transactions that would be changed by the rule. No changes will be made.
     */
    200: TransactionArray;
};

export type TestRuleResponse = TestRuleResponses[keyof TestRuleResponses];

export type FireRuleData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule.
         */
        id: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
         *
         */
        end?: string;
        /**
         * Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
         *
         */
        'accounts[]'?: Array<number>;
    };
    url: '/v1/rules/{id}/trigger';
};

export type FireRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type FireRuleError = FireRuleErrors[keyof FireRuleErrors];

export type FireRuleResponses = {
    /**
     * The rules in the group are executed. Due to the setup of this function (asynchronous job execution) the result cannot be displayed.
     */
    204: void;
};

export type FireRuleResponse = FireRuleResponses[keyof FireRuleResponses];

export type ListRuleData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/rules';
};

export type ListRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRuleError = ListRuleErrors[keyof ListRuleErrors];

export type ListRuleResponses = {
    /**
     * A list of rules
     */
    200: RuleArray;
};

export type ListRuleResponse = ListRuleResponses[keyof ListRuleResponses];

export type StoreRuleData = {
    /**
     * JSON array or key=value pairs with the necessary rule information. See the model for the exact specifications.
     */
    body: RuleStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/rules';
};

export type StoreRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreRuleError = StoreRuleErrors[keyof StoreRuleErrors];

export type StoreRuleResponses = {
    /**
     * New rule stored, result in response.
     */
    200: RuleSingle;
};

export type StoreRuleResponse = StoreRuleResponses[keyof StoreRuleResponses];

export type DeleteRuleData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the rule.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rules/{id}';
};

export type DeleteRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteRuleError = DeleteRuleErrors[keyof DeleteRuleErrors];

export type DeleteRuleResponses = {
    /**
     * Rule deleted.
     */
    204: void;
};

export type DeleteRuleResponse = DeleteRuleResponses[keyof DeleteRuleResponses];

export type GetRuleData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the object.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rules/{id}';
};

export type GetRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetRuleError = GetRuleErrors[keyof GetRuleErrors];

export type GetRuleResponses = {
    /**
     * The requested rule
     */
    200: RuleSingle;
};

export type GetRuleResponse = GetRuleResponses[keyof GetRuleResponses];

export type UpdateRuleData = {
    /**
     * JSON array with updated rule information. See the model for the exact specifications.
     */
    body: RuleUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the object.
         */
        id: string;
    };
    query?: never;
    url: '/v1/rules/{id}';
};

export type UpdateRuleErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateRuleError = UpdateRuleErrors[keyof UpdateRuleErrors];

export type UpdateRuleResponses = {
    /**
     * Updated rule stored, result in response
     */
    200: RuleSingle;
};

export type UpdateRuleResponse = UpdateRuleResponses[keyof UpdateRuleResponses];

export type ListAttachmentByTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * Either the tag itself or the tag ID.
         */
        tag: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/tags/{tag}/attachments';
};

export type ListAttachmentByTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByTagError = ListAttachmentByTagErrors[keyof ListAttachmentByTagErrors];

export type ListAttachmentByTagResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByTagResponse = ListAttachmentByTagResponses[keyof ListAttachmentByTagResponses];

export type ListTransactionByTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * Either the tag itself or the tag ID.
         */
        tag: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned.
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/tags/{tag}/transactions';
};

export type ListTransactionByTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByTagError = ListTransactionByTagErrors[keyof ListTransactionByTagErrors];

export type ListTransactionByTagResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionByTagResponse = ListTransactionByTagResponses[keyof ListTransactionByTagResponses];

export type ListTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/tags';
};

export type ListTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTagError = ListTagErrors[keyof ListTagErrors];

export type ListTagResponses = {
    /**
     * A list of tags
     */
    200: TagArray;
};

export type ListTagResponse = ListTagResponses[keyof ListTagResponses];

export type StoreTagData = {
    /**
     * JSON array or key=value pairs with the necessary tag information. See the model for the exact specifications.
     */
    body: TagModelStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/tags';
};

export type StoreTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreTagError = StoreTagErrors[keyof StoreTagErrors];

export type StoreTagResponses = {
    /**
     * New tag stored, result in response.
     */
    200: TagSingle;
};

export type StoreTagResponse = StoreTagResponses[keyof StoreTagResponses];

export type DeleteTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your mileage may vary.
         */
        tag: string;
    };
    query?: never;
    url: '/v1/tags/{tag}';
};

export type DeleteTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteTagError = DeleteTagErrors[keyof DeleteTagErrors];

export type DeleteTagResponses = {
    /**
     * Tag deleted.
     */
    204: void;
};

export type DeleteTagResponse = DeleteTagResponses[keyof DeleteTagResponses];

export type GetTagData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your mileage may vary.
         */
        tag: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/tags/{tag}';
};

export type GetTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTagError = GetTagErrors[keyof GetTagErrors];

export type GetTagResponses = {
    /**
     * The requested tag
     */
    200: TagSingle;
};

export type GetTagResponse = GetTagResponses[keyof GetTagResponses];

export type UpdateTagData = {
    /**
     * JSON array with updated tag information. See the model for the exact specifications.
     */
    body: TagModelUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your mileage may vary.
         */
        tag: string;
    };
    query?: never;
    url: '/v1/tags/{tag}';
};

export type UpdateTagErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateTagError = UpdateTagErrors[keyof UpdateTagErrors];

export type UpdateTagResponses = {
    /**
     * Updated tag stored, result in response
     */
    200: TagSingle;
};

export type UpdateTagResponse = UpdateTagResponses[keyof UpdateTagResponses];

export type ListAccountByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
         *
         */
        date?: string;
        /**
         * Optional filter on the account type(s) returned
         */
        type?: AccountTypeFilter;
    };
    url: '/v1/currencies/{code}/accounts';
};

export type ListAccountByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAccountByCurrencyError = ListAccountByCurrencyErrors[keyof ListAccountByCurrencyErrors];

export type ListAccountByCurrencyResponses = {
    /**
     * A list of accounts
     */
    200: AccountArray;
};

export type ListAccountByCurrencyResponse = ListAccountByCurrencyResponses[keyof ListAccountByCurrencyResponses];

export type ListAvailableBudgetByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/currencies/{code}/available-budgets';
};

export type ListAvailableBudgetByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAvailableBudgetByCurrencyError = ListAvailableBudgetByCurrencyErrors[keyof ListAvailableBudgetByCurrencyErrors];

export type ListAvailableBudgetByCurrencyResponses = {
    /**
     * A list of available budgets
     */
    200: AvailableBudgetArray;
};

export type ListAvailableBudgetByCurrencyResponse = ListAvailableBudgetByCurrencyResponses[keyof ListAvailableBudgetByCurrencyResponses];

export type ListBillByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/currencies/{code}/bills';
};

export type ListBillByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBillByCurrencyError = ListBillByCurrencyErrors[keyof ListBillByCurrencyErrors];

export type ListBillByCurrencyResponses = {
    /**
     * A list of bills.
     */
    200: BillArray;
};

export type ListBillByCurrencyResponse = ListBillByCurrencyResponses[keyof ListBillByCurrencyResponses];

export type ListBudgetLimitByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * Start date for the budget limit list.
         */
        start?: string;
        /**
         * End date for the budget limit list.
         */
        end?: string;
    };
    url: '/v1/currencies/{code}/budget-limits';
};

export type ListBudgetLimitByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListBudgetLimitByCurrencyError = ListBudgetLimitByCurrencyErrors[keyof ListBudgetLimitByCurrencyErrors];

export type ListBudgetLimitByCurrencyResponses = {
    /**
     * A list of budget limits.
     */
    200: BudgetLimitArray;
};

export type ListBudgetLimitByCurrencyResponse = ListBudgetLimitByCurrencyResponses[keyof ListBudgetLimitByCurrencyResponses];

export type ListRecurrenceByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/currencies/{code}/recurrences';
};

export type ListRecurrenceByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRecurrenceByCurrencyError = ListRecurrenceByCurrencyErrors[keyof ListRecurrenceByCurrencyErrors];

export type ListRecurrenceByCurrencyResponses = {
    /**
     * A list of recurring transactions
     */
    200: RecurrenceArray;
};

export type ListRecurrenceByCurrencyResponse = ListRecurrenceByCurrencyResponses[keyof ListRecurrenceByCurrencyResponses];

export type ListRuleByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/currencies/{code}/rules';
};

export type ListRuleByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListRuleByCurrencyError = ListRuleByCurrencyErrors[keyof ListRuleByCurrencyErrors];

export type ListRuleByCurrencyResponses = {
    /**
     * A list of rules
     */
    200: RuleArray;
};

export type ListRuleByCurrencyResponse = ListRuleByCurrencyResponses[keyof ListRuleByCurrencyResponses];

export type ListTransactionByCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD, to limit the list of transactions.
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD, to limit the list of transactions.
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/currencies/{code}/transactions';
};

export type ListTransactionByCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionByCurrencyError = ListTransactionByCurrencyErrors[keyof ListTransactionByCurrencyErrors];

export type ListTransactionByCurrencyResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionByCurrencyResponse = ListTransactionByCurrencyResponses[keyof ListTransactionByCurrencyResponses];

export type ListCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/currencies';
};

export type ListCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListCurrencyError = ListCurrencyErrors[keyof ListCurrencyErrors];

export type ListCurrencyResponses = {
    /**
     * A list of currencies.
     */
    200: CurrencyArray;
};

export type ListCurrencyResponse = ListCurrencyResponses[keyof ListCurrencyResponses];

export type StoreCurrencyData = {
    /**
     * JSON array or key=value pairs with the necessary currency information. See the model for the exact specifications.
     */
    body: CurrencyStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/currencies';
};

export type StoreCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreCurrencyError = StoreCurrencyErrors[keyof StoreCurrencyErrors];

export type StoreCurrencyResponses = {
    /**
     * New currency stored, result in response.
     */
    200: CurrencySingle;
};

export type StoreCurrencyResponse = StoreCurrencyResponses[keyof StoreCurrencyResponses];

export type EnableCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}/enable';
};

export type EnableCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type EnableCurrencyError = EnableCurrencyErrors[keyof EnableCurrencyErrors];

export type EnableCurrencyResponses = {
    /**
     * Currency was enabled.
     */
    204: CurrencySingle;
};

export type EnableCurrencyResponse = EnableCurrencyResponses[keyof EnableCurrencyResponses];

export type DisableCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}/disable';
};

export type DisableCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Currency cannot be disabled, because it is still in use.
     */
    409: InternalExceptionResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DisableCurrencyError = DisableCurrencyErrors[keyof DisableCurrencyErrors];

export type DisableCurrencyResponses = {
    /**
     * Currency was disabled.
     */
    204: CurrencySingle;
};

export type DisableCurrencyResponse = DisableCurrencyResponses[keyof DisableCurrencyResponses];

export type PrimaryCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}/primary';
};

export type PrimaryCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type PrimaryCurrencyError = PrimaryCurrencyErrors[keyof PrimaryCurrencyErrors];

export type PrimaryCurrencyResponses = {
    /**
     * Currency has been made the primary currency.
     */
    204: CurrencySingle;
};

export type PrimaryCurrencyResponse = PrimaryCurrencyResponses[keyof PrimaryCurrencyResponses];

export type DeleteCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}';
};

export type DeleteCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteCurrencyError = DeleteCurrencyErrors[keyof DeleteCurrencyErrors];

export type DeleteCurrencyResponses = {
    /**
     * Currency deleted.
     */
    204: void;
};

export type DeleteCurrencyResponse = DeleteCurrencyResponses[keyof DeleteCurrencyResponses];

export type GetCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}';
};

export type GetCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCurrencyError = GetCurrencyErrors[keyof GetCurrencyErrors];

export type GetCurrencyResponses = {
    /**
     * The requested currency
     */
    200: CurrencySingle;
};

export type GetCurrencyResponse = GetCurrencyResponses[keyof GetCurrencyResponses];

export type UpdateCurrencyData = {
    /**
     * JSON array with updated currency information. See the model for the exact specifications.
     */
    body: CurrencyUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The currency code.
         */
        code: string;
    };
    query?: never;
    url: '/v1/currencies/{code}';
};

export type UpdateCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateCurrencyError = UpdateCurrencyErrors[keyof UpdateCurrencyErrors];

export type UpdateCurrencyResponses = {
    /**
     * Updated currency stored, result in response
     */
    200: CurrencySingle;
};

export type UpdateCurrencyResponse = UpdateCurrencyResponses[keyof UpdateCurrencyResponses];

export type GetPrimaryCurrencyData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/currencies/primary';
};

export type GetPrimaryCurrencyErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetPrimaryCurrencyError = GetPrimaryCurrencyErrors[keyof GetPrimaryCurrencyErrors];

export type GetPrimaryCurrencyResponses = {
    /**
     * The primary currency
     */
    200: CurrencySingle;
};

export type GetPrimaryCurrencyResponse = GetPrimaryCurrencyResponses[keyof GetPrimaryCurrencyResponses];

export type ListLinksByJournalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction journal / the split.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/transaction-journals/{id}/links';
};

export type ListLinksByJournalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListLinksByJournalError = ListLinksByJournalErrors[keyof ListLinksByJournalErrors];

export type ListLinksByJournalResponses = {
    /**
     * A list of transaction links.
     */
    200: TransactionLinkArray;
};

export type ListLinksByJournalResponse = ListLinksByJournalResponses[keyof ListLinksByJournalResponses];

export type DeleteTransactionJournalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction journal (the split) you wish to delete.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transaction-journals/{id}';
};

export type DeleteTransactionJournalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteTransactionJournalError = DeleteTransactionJournalErrors[keyof DeleteTransactionJournalErrors];

export type DeleteTransactionJournalResponses = {
    /**
     * Transaction journal (split) deleted.
     */
    204: void;
};

export type DeleteTransactionJournalResponse = DeleteTransactionJournalResponses[keyof DeleteTransactionJournalResponses];

export type GetTransactionByJournalData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction journal (split).
         */
        id: string;
    };
    query?: never;
    url: '/v1/transaction-journals/{id}';
};

export type GetTransactionByJournalErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionByJournalError = GetTransactionByJournalErrors[keyof GetTransactionByJournalErrors];

export type GetTransactionByJournalResponses = {
    /**
     * The requested transaction.
     */
    200: TransactionSingle;
};

export type GetTransactionByJournalResponse = GetTransactionByJournalResponses[keyof GetTransactionByJournalResponses];

export type ListAttachmentByTransactionData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/transactions/{id}/attachments';
};

export type ListAttachmentByTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListAttachmentByTransactionError = ListAttachmentByTransactionErrors[keyof ListAttachmentByTransactionErrors];

export type ListAttachmentByTransactionResponses = {
    /**
     * A list of attachments
     */
    200: AttachmentArray;
};

export type ListAttachmentByTransactionResponse = ListAttachmentByTransactionResponses[keyof ListAttachmentByTransactionResponses];

export type ListEventByTransactionData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction.
         */
        id: string;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/transactions/{id}/piggy-bank-events';
};

export type ListEventByTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListEventByTransactionError = ListEventByTransactionErrors[keyof ListEventByTransactionErrors];

export type ListEventByTransactionResponses = {
    /**
     * A list of piggy bank events.
     */
    200: PiggyBankEventArray;
};

export type ListEventByTransactionResponse = ListEventByTransactionResponses[keyof ListEventByTransactionResponses];

export type ListTransactionData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
         *
         */
        start?: string;
        /**
         * A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
         *
         */
        end?: string;
        /**
         * Optional filter on the transaction type(s) returned.
         */
        type?: TransactionTypeFilter;
    };
    url: '/v1/transactions';
};

export type ListTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListTransactionError = ListTransactionErrors[keyof ListTransactionErrors];

export type ListTransactionResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type ListTransactionResponse = ListTransactionResponses[keyof ListTransactionResponses];

export type StoreTransactionData = {
    /**
     * JSON array or key=value pairs with the necessary transaction information. See the model for the exact specifications.
     */
    body: TransactionStoreWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/transactions';
};

export type StoreTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreTransactionError = StoreTransactionErrors[keyof StoreTransactionErrors];

export type StoreTransactionResponses = {
    /**
     * New transaction stored(s), result in response.
     */
    200: TransactionSingle;
};

export type StoreTransactionResponse = StoreTransactionResponses[keyof StoreTransactionResponses];

export type DeleteTransactionData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transactions/{id}';
};

export type DeleteTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteTransactionError = DeleteTransactionErrors[keyof DeleteTransactionErrors];

export type DeleteTransactionResponses = {
    /**
     * Transaction deleted.
     */
    204: void;
};

export type DeleteTransactionResponse = DeleteTransactionResponses[keyof DeleteTransactionResponses];

export type GetTransactionData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transactions/{id}';
};

export type GetTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetTransactionError = GetTransactionErrors[keyof GetTransactionErrors];

export type GetTransactionResponses = {
    /**
     * The requested transaction.
     */
    200: TransactionSingle;
};

export type GetTransactionResponse = GetTransactionResponses[keyof GetTransactionResponses];

export type UpdateTransactionData = {
    /**
     * JSON array with updated transaction information. See the model for the exact specifications.
     */
    body: TransactionUpdateWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the transaction.
         */
        id: string;
    };
    query?: never;
    url: '/v1/transactions/{id}';
};

export type UpdateTransactionErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateTransactionError = UpdateTransactionErrors[keyof UpdateTransactionErrors];

export type UpdateTransactionResponses = {
    /**
     * Updated transaction stored, result in response
     */
    200: TransactionSingle;
};

export type UpdateTransactionResponse = UpdateTransactionResponses[keyof UpdateTransactionResponses];

export type ListUserGroupsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/user-groups';
};

export type ListUserGroupsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListUserGroupsError = ListUserGroupsErrors[keyof ListUserGroupsErrors];

export type ListUserGroupsResponses = {
    /**
     * A list of user groups.
     */
    200: UserGroupArray;
};

export type ListUserGroupsResponse = ListUserGroupsResponses[keyof ListUserGroupsResponses];

export type GetUserGroupData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the user group.
         */
        id: string;
    };
    query?: never;
    url: '/v1/user-groups/{id}';
};

export type GetUserGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetUserGroupError = GetUserGroupErrors[keyof GetUserGroupErrors];

export type GetUserGroupResponses = {
    /**
     * The requested user group
     */
    200: UserGroupSingle;
};

export type GetUserGroupResponse = GetUserGroupResponses[keyof GetUserGroupResponses];

export type UpdateUserGroupData = {
    /**
     * JSON array or form-data with new user group information. See the model for the exact specifications.
     */
    body: UserGroupUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The ID of the account.
         */
        id: string;
    };
    query?: never;
    url: '/v1/user-groups/{id}';
};

export type UpdateUserGroupErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateUserGroupError = UpdateUserGroupErrors[keyof UpdateUserGroupErrors];

export type UpdateUserGroupResponses = {
    /**
     * Updated user group is stored, result is in the response
     */
    200: UserGroupSingle;
};

export type UpdateUserGroupResponse = UpdateUserGroupResponses[keyof UpdateUserGroupResponses];

export type SearchAccountsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * The query you wish to search for.
         */
        query: string;
        /**
         * The type of accounts you wish to limit the search to.
         */
        type?: AccountTypeFilter;
        /**
         * The account field(s) you want to search in.
         */
        field: AccountSearchFieldFilter;
    };
    url: '/v1/search/accounts';
};

export type SearchAccountsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type SearchAccountsError = SearchAccountsErrors[keyof SearchAccountsErrors];

export type SearchAccountsResponses = {
    /**
     * A list of accounts.
     */
    200: AccountArray;
};

export type SearchAccountsResponse = SearchAccountsResponses[keyof SearchAccountsResponses];

export type SearchTransactionsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
        /**
         * The query you wish to search for.
         */
        query: string;
    };
    url: '/v1/search/transactions';
};

export type SearchTransactionsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type SearchTransactionsError = SearchTransactionsErrors[keyof SearchTransactionsErrors];

export type SearchTransactionsResponses = {
    /**
     * A list of transactions.
     */
    200: TransactionArray;
};

export type SearchTransactionsResponse = SearchTransactionsResponses[keyof SearchTransactionsResponses];

export type GetBasicSummaryData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query: {
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        start: string;
        /**
         * A date formatted YYYY-MM-DD.
         *
         */
        end: string;
        /**
         * A currency code like EUR or USD, to filter the result.
         *
         */
        currency_code?: string;
    };
    url: '/v1/summary/basic';
};

export type GetBasicSummaryErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetBasicSummaryError = GetBasicSummaryErrors[keyof GetBasicSummaryErrors];

export type GetBasicSummaryResponses = {
    /**
     * An array of sums. It depends on the user what you can expect to get back, so please try this out on the demo site.
     */
    200: BasicSummary;
};

export type GetBasicSummaryResponse = GetBasicSummaryResponses[keyof GetBasicSummaryResponses];

export type GetAboutData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/about';
};

export type GetAboutErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetAboutError = GetAboutErrors[keyof GetAboutErrors];

export type GetAboutResponses = {
    /**
     * The available system information
     */
    200: SystemInfo;
};

export type GetAboutResponse = GetAboutResponses[keyof GetAboutResponses];

export type GetCurrentUserData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/about/user';
};

export type GetCurrentUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * The user
     */
    200: UserSingle;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type GetConfigurationData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/configuration';
};

export type GetConfigurationErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetConfigurationError = GetConfigurationErrors[keyof GetConfigurationErrors];

export type GetConfigurationResponses = {
    /**
     * System configuration values
     */
    200: ConfigurationArray;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type GetSingleConfigurationData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The name of the configuration value you want to know.
         */
        name: ConfigValueFilter;
    };
    query?: never;
    url: '/v1/configuration/{name}';
};

export type GetSingleConfigurationErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetSingleConfigurationError = GetSingleConfigurationErrors[keyof GetSingleConfigurationErrors];

export type GetSingleConfigurationResponses = {
    /**
     * One system configuration value
     */
    200: ConfigurationSingle;
};

export type GetSingleConfigurationResponse = GetSingleConfigurationResponses[keyof GetSingleConfigurationResponses];

export type SetConfigurationData = {
    /**
     * JSON array with the necessary account information or key=value pairs. See the model for the exact specifications.
     */
    body: ConfigurationUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The name of the configuration value you want to update.
         */
        name: ConfigValueUpdateFilter;
    };
    query?: never;
    url: '/v1/configuration/{name}';
};

export type SetConfigurationErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type SetConfigurationError = SetConfigurationErrors[keyof SetConfigurationErrors];

export type SetConfigurationResponses = {
    /**
     * New configuration value stored, result in response.
     */
    200: ConfigurationSingle;
};

export type SetConfigurationResponse = SetConfigurationResponses[keyof SetConfigurationResponses];

export type GetCronData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The CLI token of any user in Firefly III, required to run the cron job.
         */
        cliToken: string;
    };
    query?: {
        /**
         * A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it's running
         * on another day.
         *
         */
        date?: string;
        /**
         * Forces the cron job to fire, regardless of whether it has fired before. This may result
         * in double transactions or weird budgets, so be careful.
         *
         */
        force?: boolean;
    };
    url: '/v1/cron/{cliToken}';
};

export type GetCronErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetCronError = GetCronErrors[keyof GetCronErrors];

export type GetCronResponses = {
    /**
     * The result of the cron job(s) firing.
     */
    200: CronResult;
};

export type GetCronResponse = GetCronResponses[keyof GetCronResponses];

export type ListUserData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/users';
};

export type ListUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListUserError = ListUserErrors[keyof ListUserErrors];

export type ListUserResponses = {
    /**
     * A list of users.
     */
    200: UserArray;
};

export type ListUserResponse = ListUserResponses[keyof ListUserResponses];

export type StoreUserData = {
    /**
     * JSON array or key=value pairs with the necessary user information. See the model for the exact specifications.
     */
    body: UserWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type StoreUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreUserError = StoreUserErrors[keyof StoreUserErrors];

export type StoreUserResponses = {
    /**
     * New user stored, result in response.
     */
    200: UserSingle;
};

export type StoreUserResponse = StoreUserResponses[keyof StoreUserResponses];

export type DeleteUserData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The user ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}';
};

export type DeleteUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];

export type DeleteUserResponses = {
    /**
     * User deleted.
     */
    204: void;
};

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export type GetUserData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The user ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}';
};

export type GetUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * The requested user.
     */
    200: UserSingle;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type UpdateUserData = {
    /**
     * JSON array with updated user information. See the model for the exact specifications.
     */
    body: UserWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The user ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/users/{id}';
};

export type UpdateUserErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * Updated user stored, result in response
     */
    200: UserSingle;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type ListPreferenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/preferences';
};

export type ListPreferenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListPreferenceError = ListPreferenceErrors[keyof ListPreferenceErrors];

export type ListPreferenceResponses = {
    /**
     * A list of preferences.
     */
    200: PreferenceArray;
};

export type ListPreferenceResponse = ListPreferenceResponses[keyof ListPreferenceResponses];

export type StorePreferenceData = {
    /**
     * JSON array with the necessary preference information or key=value pairs. See the model for the exact specifications.
     */
    body: PreferenceWritable;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type StorePreferenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StorePreferenceError = StorePreferenceErrors[keyof StorePreferenceErrors];

export type StorePreferenceResponses = {
    /**
     * New account stored, result in response.
     */
    200: PreferenceSingle;
};

export type StorePreferenceResponse = StorePreferenceResponses[keyof StorePreferenceResponses];

export type GetPreferenceData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The name of the preference.
         */
        name: string;
    };
    query?: never;
    url: '/v1/preferences/{name}';
};

export type GetPreferenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetPreferenceError = GetPreferenceErrors[keyof GetPreferenceErrors];

export type GetPreferenceResponses = {
    /**
     * A single preference.
     */
    200: PreferenceSingle;
};

export type GetPreferenceResponse = GetPreferenceResponses[keyof GetPreferenceResponses];

export type UpdatePreferenceData = {
    /**
     * JSON array or key=value pairs with the necessary preference information. See the model for the exact specifications.
     */
    body: PreferenceUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The name of the preference. Will always overwrite. Will be created if it does not exist.
         */
        name: string;
    };
    query?: never;
    url: '/v1/preferences/{name}';
};

export type UpdatePreferenceErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdatePreferenceError = UpdatePreferenceErrors[keyof UpdatePreferenceErrors];

export type UpdatePreferenceResponses = {
    /**
     * Updated preference.
     */
    200: PreferenceSingle;
};

export type UpdatePreferenceResponse = UpdatePreferenceResponses[keyof UpdatePreferenceResponses];

export type GetWebhookMessagesData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}/messages';
};

export type GetWebhookMessagesErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetWebhookMessagesError = GetWebhookMessagesErrors[keyof GetWebhookMessagesErrors];

export type GetWebhookMessagesResponses = {
    /**
     * A list of webhook messages.
     */
    200: WebhookMessageArray;
};

export type GetWebhookMessagesResponse = GetWebhookMessagesResponses[keyof GetWebhookMessagesResponses];

export type DeleteWebhookMessageData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The webhook message ID.
         */
        messageId: number;
    };
    query?: never;
    url: '/v1/webhooks/{id}/messages/{messageId}';
};

export type DeleteWebhookMessageErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteWebhookMessageError = DeleteWebhookMessageErrors[keyof DeleteWebhookMessageErrors];

export type DeleteWebhookMessageResponses = {
    /**
     * Webhook message deleted.
     */
    204: void;
};

export type DeleteWebhookMessageResponse = DeleteWebhookMessageResponses[keyof DeleteWebhookMessageResponses];

export type GetSingleWebhookMessageData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The webhook message ID.
         */
        messageId: number;
    };
    query?: never;
    url: '/v1/webhooks/{id}/messages/{messageId}';
};

export type GetSingleWebhookMessageErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetSingleWebhookMessageError = GetSingleWebhookMessageErrors[keyof GetSingleWebhookMessageErrors];

export type GetSingleWebhookMessageResponses = {
    /**
     * A single webhook message.
     */
    200: WebhookMessageSingle;
};

export type GetSingleWebhookMessageResponse = GetSingleWebhookMessageResponses[keyof GetSingleWebhookMessageResponses];

export type GetWebhookMessageAttemptsData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The webhook message ID.
         */
        messageId: number;
    };
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts';
};

export type GetWebhookMessageAttemptsErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetWebhookMessageAttemptsError = GetWebhookMessageAttemptsErrors[keyof GetWebhookMessageAttemptsErrors];

export type GetWebhookMessageAttemptsResponses = {
    /**
     * A list of webhook attempts.
     */
    200: WebhookAttemptArray;
};

export type GetWebhookMessageAttemptsResponse = GetWebhookMessageAttemptsResponses[keyof GetWebhookMessageAttemptsResponses];

export type DeleteWebhookMessageAttemptData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The webhook message ID.
         */
        messageId: number;
        /**
         * The webhook message attempt ID.
         */
        attemptId: number;
    };
    query?: never;
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}';
};

export type DeleteWebhookMessageAttemptErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteWebhookMessageAttemptError = DeleteWebhookMessageAttemptErrors[keyof DeleteWebhookMessageAttemptErrors];

export type DeleteWebhookMessageAttemptResponses = {
    /**
     * Webhook message attempt deleted.
     */
    204: void;
};

export type DeleteWebhookMessageAttemptResponse = DeleteWebhookMessageAttemptResponses[keyof DeleteWebhookMessageAttemptResponses];

export type GetSingleWebhookMessageAttemptData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The webhook message ID.
         */
        messageId: number;
        /**
         * The webhook attempt ID.
         */
        attemptId: number;
    };
    query?: never;
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}';
};

export type GetSingleWebhookMessageAttemptErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetSingleWebhookMessageAttemptError = GetSingleWebhookMessageAttemptErrors[keyof GetSingleWebhookMessageAttemptErrors];

export type GetSingleWebhookMessageAttemptResponses = {
    /**
     * A single webhook attempt.
     */
    200: WebhookAttemptSingle;
};

export type GetSingleWebhookMessageAttemptResponse = GetSingleWebhookMessageAttemptResponses[keyof GetSingleWebhookMessageAttemptResponses];

export type SubmitWebhookData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}/submit';
};

export type SubmitWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type SubmitWebhookError = SubmitWebhookErrors[keyof SubmitWebhookErrors];

export type SubmitWebhookResponses = {
    /**
     * OK.
     */
    200: unknown;
    /**
     * No messages to send, so did nothing.
     */
    204: void;
};

export type SubmitWebhookResponse = SubmitWebhookResponses[keyof SubmitWebhookResponses];

export type TriggerTransactionWebhookData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
        /**
         * The transaction ID.
         */
        transactionId: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}/trigger-transaction/{transactionId}';
};

export type TriggerTransactionWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type TriggerTransactionWebhookError = TriggerTransactionWebhookErrors[keyof TriggerTransactionWebhookErrors];

export type TriggerTransactionWebhookResponses = {
    /**
     * Webhook triggered successfully.
     */
    204: void;
};

export type TriggerTransactionWebhookResponse = TriggerTransactionWebhookResponses[keyof TriggerTransactionWebhookResponses];

export type ListWebhookData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: {
        /**
         * Number of items per page. The default pagination is per 50 items.
         */
        limit?: number;
        /**
         * Page number. The default pagination is per 50 items.
         */
        page?: number;
    };
    url: '/v1/webhooks';
};

export type ListWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type ListWebhookError = ListWebhookErrors[keyof ListWebhookErrors];

export type ListWebhookResponses = {
    /**
     * A list of webhooks.
     */
    200: WebhookArray;
};

export type ListWebhookResponse = ListWebhookResponses[keyof ListWebhookResponses];

export type StoreWebhookData = {
    /**
     * JSON array or key=value pairs with the necessary webhook information. See the model for the exact specifications.
     */
    body: WebhookStore;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/webhooks';
};

export type StoreWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type StoreWebhookError = StoreWebhookErrors[keyof StoreWebhookErrors];

export type StoreWebhookResponses = {
    /**
     * New webhook stored, result in response.
     */
    200: WebhookSingle;
};

export type StoreWebhookResponse = StoreWebhookResponses[keyof StoreWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}';
};

export type DeleteWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type DeleteWebhookError = DeleteWebhookErrors[keyof DeleteWebhookErrors];

export type DeleteWebhookResponses = {
    /**
     * Webhook deleted.
     */
    204: void;
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type GetWebhookData = {
    body?: never;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}';
};

export type GetWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type GetWebhookError = GetWebhookErrors[keyof GetWebhookErrors];

export type GetWebhookResponses = {
    /**
     * The requested webhook.
     */
    200: WebhookSingle;
};

export type GetWebhookResponse = GetWebhookResponses[keyof GetWebhookResponses];

export type UpdateWebhookData = {
    /**
     * JSON array with updated webhook information. See the model for the exact specifications.
     */
    body: WebhookUpdate;
    headers?: {
        /**
         * Unique identifier associated with this request.
         */
        'X-Trace-Id'?: string;
    };
    path: {
        /**
         * The webhook ID.
         */
        id: string;
    };
    query?: never;
    url: '/v1/webhooks/{id}';
};

export type UpdateWebhookErrors = {
    /**
     * Bad request
     */
    400: BadRequestResponse;
    /**
     * Unauthenticated
     */
    401: UnauthenticatedResponse;
    /**
     * Page not found
     */
    404: NotFoundResponse;
    /**
     * Validation error. The body will have the exact details.
     */
    422: ValidationErrorResponse;
    /**
     * Internal exception
     */
    500: InternalExceptionResponse;
};

export type UpdateWebhookError = UpdateWebhookErrors[keyof UpdateWebhookErrors];

export type UpdateWebhookResponses = {
    /**
     * Updated webhook stored, result in response
     */
    200: WebhookSingle;
};

export type UpdateWebhookResponse = UpdateWebhookResponses[keyof UpdateWebhookResponses];
