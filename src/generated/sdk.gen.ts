// This file is auto-generated by @hey-api/openapi-ts

import { client } from './client.gen.js';
import type { Client, Options as Options2, TDataShape } from './client/index.js';
import type { BulkUpdateTransactionsData, BulkUpdateTransactionsErrors, BulkUpdateTransactionsResponses, DeleteAccountData, DeleteAccountErrors, DeleteAccountResponses, DeleteAttachmentData, DeleteAttachmentErrors, DeleteAttachmentResponses, DeleteBillData, DeleteBillErrors, DeleteBillResponses, DeleteBudgetData, DeleteBudgetErrors, DeleteBudgetLimitData, DeleteBudgetLimitErrors, DeleteBudgetLimitResponses, DeleteBudgetResponses, DeleteCategoryData, DeleteCategoryErrors, DeleteCategoryResponses, DeleteCurrencyData, DeleteCurrencyErrors, DeleteCurrencyResponses, DeleteLinkTypeData, DeleteLinkTypeErrors, DeleteLinkTypeResponses, DeleteObjectGroupData, DeleteObjectGroupErrors, DeleteObjectGroupResponses, DeletePiggyBankData, DeletePiggyBankErrors, DeletePiggyBankResponses, DeleteRecurrenceData, DeleteRecurrenceErrors, DeleteRecurrenceResponses, DeleteRuleData, DeleteRuleErrors, DeleteRuleGroupData, DeleteRuleGroupErrors, DeleteRuleGroupResponses, DeleteRuleResponses, DeleteSpecificCurrencyExchangeRateData, DeleteSpecificCurrencyExchangeRateErrors, DeleteSpecificCurrencyExchangeRateOnDateData, DeleteSpecificCurrencyExchangeRateOnDateErrors, DeleteSpecificCurrencyExchangeRateOnDateResponses, DeleteSpecificCurrencyExchangeRateResponses, DeleteSpecificCurrencyExchangeRatesData, DeleteSpecificCurrencyExchangeRatesErrors, DeleteSpecificCurrencyExchangeRatesResponses, DeleteTagData, DeleteTagErrors, DeleteTagResponses, DeleteTransactionData, DeleteTransactionErrors, DeleteTransactionJournalData, DeleteTransactionJournalErrors, DeleteTransactionJournalResponses, DeleteTransactionLinkData, DeleteTransactionLinkErrors, DeleteTransactionLinkResponses, DeleteTransactionResponses, DeleteUserData, DeleteUserErrors, DeleteUserResponses, DeleteWebhookData, DeleteWebhookErrors, DeleteWebhookMessageAttemptData, DeleteWebhookMessageAttemptErrors, DeleteWebhookMessageAttemptResponses, DeleteWebhookMessageData, DeleteWebhookMessageErrors, DeleteWebhookMessageResponses, DeleteWebhookResponses, DestroyDataData, DestroyDataErrors, DestroyDataResponses, DisableCurrencyData, DisableCurrencyErrors, DisableCurrencyResponses, DownloadAttachmentData, DownloadAttachmentErrors, DownloadAttachmentResponses, EnableCurrencyData, EnableCurrencyErrors, EnableCurrencyResponses, ExportAccountsData, ExportAccountsErrors, ExportAccountsResponses, ExportBillsData, ExportBillsErrors, ExportBillsResponses, ExportBudgetsData, ExportBudgetsErrors, ExportBudgetsResponses, ExportCategoriesData, ExportCategoriesErrors, ExportCategoriesResponses, ExportPiggiesData, ExportPiggiesErrors, ExportPiggiesResponses, ExportRecurringData, ExportRecurringErrors, ExportRecurringResponses, ExportRulesData, ExportRulesErrors, ExportRulesResponses, ExportTagsData, ExportTagsErrors, ExportTagsResponses, ExportTransactionsData, ExportTransactionsErrors, ExportTransactionsResponses, FireRuleData, FireRuleErrors, FireRuleGroupData, FireRuleGroupErrors, FireRuleGroupResponses, FireRuleResponses, GetAboutData, GetAboutErrors, GetAboutResponses, GetAccountData, GetAccountErrors, GetAccountResponses, GetAccountsAcData, GetAccountsAcErrors, GetAccountsAcResponses, GetAttachmentData, GetAttachmentErrors, GetAttachmentResponses, GetAvailableBudgetData, GetAvailableBudgetErrors, GetAvailableBudgetResponses, GetBasicSummaryData, GetBasicSummaryErrors, GetBasicSummaryResponses, GetBillData, GetBillErrors, GetBillResponses, GetBillsAcData, GetBillsAcErrors, GetBillsAcResponses, GetBudgetData, GetBudgetErrors, GetBudgetLimitData, GetBudgetLimitErrors, GetBudgetLimitResponses, GetBudgetResponses, GetBudgetsAcData, GetBudgetsAcErrors, GetBudgetsAcResponses, GetCategoriesAcData, GetCategoriesAcErrors, GetCategoriesAcResponses, GetCategoryData, GetCategoryErrors, GetCategoryResponses, GetChartAccountOverviewData, GetChartAccountOverviewErrors, GetChartAccountOverviewResponses, GetChartBalanceData, GetChartBalanceErrors, GetChartBalanceResponses, GetChartBudgetOverviewData, GetChartBudgetOverviewErrors, GetChartBudgetOverviewResponses, GetChartCategoryOverviewData, GetChartCategoryOverviewErrors, GetChartCategoryOverviewResponses, GetConfigurationData, GetConfigurationErrors, GetConfigurationResponses, GetCronData, GetCronErrors, GetCronResponses, GetCurrenciesAcData, GetCurrenciesAcErrors, GetCurrenciesAcResponses, GetCurrenciesCodeAcData, GetCurrenciesCodeAcErrors, GetCurrenciesCodeAcResponses, GetCurrencyData, GetCurrencyErrors, GetCurrencyResponses, GetCurrentUserData, GetCurrentUserErrors, GetCurrentUserResponses, GetLinkTypeData, GetLinkTypeErrors, GetLinkTypeResponses, GetObjectGroupData, GetObjectGroupErrors, GetObjectGroupResponses, GetObjectGroupsAcData, GetObjectGroupsAcErrors, GetObjectGroupsAcResponses, GetPiggiesAcData, GetPiggiesAcErrors, GetPiggiesAcResponses, GetPiggiesBalanceAcData, GetPiggiesBalanceAcErrors, GetPiggiesBalanceAcResponses, GetPiggyBankData, GetPiggyBankErrors, GetPiggyBankResponses, GetPreferenceData, GetPreferenceErrors, GetPreferenceResponses, GetPrimaryCurrencyData, GetPrimaryCurrencyErrors, GetPrimaryCurrencyResponses, GetRecurrenceData, GetRecurrenceErrors, GetRecurrenceResponses, GetRecurringAcData, GetRecurringAcErrors, GetRecurringAcResponses, GetRuleData, GetRuleErrors, GetRuleGroupData, GetRuleGroupErrors, GetRuleGroupResponses, GetRuleGroupsAcData, GetRuleGroupsAcErrors, GetRuleGroupsAcResponses, GetRuleResponses, GetRulesAcData, GetRulesAcErrors, GetRulesAcResponses, GetSingleConfigurationData, GetSingleConfigurationErrors, GetSingleConfigurationResponses, GetSingleWebhookMessageAttemptData, GetSingleWebhookMessageAttemptErrors, GetSingleWebhookMessageAttemptResponses, GetSingleWebhookMessageData, GetSingleWebhookMessageErrors, GetSingleWebhookMessageResponses, GetSubscriptionsAcData, GetSubscriptionsAcErrors, GetSubscriptionsAcResponses, GetTagAcData, GetTagAcErrors, GetTagAcResponses, GetTagData, GetTagErrors, GetTagResponses, GetTransactionByJournalData, GetTransactionByJournalErrors, GetTransactionByJournalResponses, GetTransactionData, GetTransactionErrors, GetTransactionLinkData, GetTransactionLinkErrors, GetTransactionLinkResponses, GetTransactionResponses, GetTransactionsAcData, GetTransactionsAcErrors, GetTransactionsAcResponses, GetTransactionsIdacData, GetTransactionsIdacErrors, GetTransactionsIdacResponses, GetTransactionTypesAcData, GetTransactionTypesAcErrors, GetTransactionTypesAcResponses, GetUserData, GetUserErrors, GetUserGroupData, GetUserGroupErrors, GetUserGroupResponses, GetUserResponses, GetWebhookData, GetWebhookErrors, GetWebhookMessageAttemptsData, GetWebhookMessageAttemptsErrors, GetWebhookMessageAttemptsResponses, GetWebhookMessagesData, GetWebhookMessagesErrors, GetWebhookMessagesResponses, GetWebhookResponses, InsightExpenseAssetData, InsightExpenseAssetErrors, InsightExpenseAssetResponses, InsightExpenseBillData, InsightExpenseBillErrors, InsightExpenseBillResponses, InsightExpenseBudgetData, InsightExpenseBudgetErrors, InsightExpenseBudgetResponses, InsightExpenseCategoryData, InsightExpenseCategoryErrors, InsightExpenseCategoryResponses, InsightExpenseExpenseData, InsightExpenseExpenseErrors, InsightExpenseExpenseResponses, InsightExpenseNoBillData, InsightExpenseNoBillErrors, InsightExpenseNoBillResponses, InsightExpenseNoBudgetData, InsightExpenseNoBudgetErrors, InsightExpenseNoBudgetResponses, InsightExpenseNoCategoryData, InsightExpenseNoCategoryErrors, InsightExpenseNoCategoryResponses, InsightExpenseNoTagData, InsightExpenseNoTagErrors, InsightExpenseNoTagResponses, InsightExpenseTagData, InsightExpenseTagErrors, InsightExpenseTagResponses, InsightExpenseTotalData, InsightExpenseTotalErrors, InsightExpenseTotalResponses, InsightIncomeAssetData, InsightIncomeAssetErrors, InsightIncomeAssetResponses, InsightIncomeCategoryData, InsightIncomeCategoryErrors, InsightIncomeCategoryResponses, InsightIncomeNoCategoryData, InsightIncomeNoCategoryErrors, InsightIncomeNoCategoryResponses, InsightIncomeNoTagData, InsightIncomeNoTagErrors, InsightIncomeNoTagResponses, InsightIncomeRevenueData, InsightIncomeRevenueErrors, InsightIncomeRevenueResponses, InsightIncomeTagData, InsightIncomeTagErrors, InsightIncomeTagResponses, InsightIncomeTotalData, InsightIncomeTotalErrors, InsightIncomeTotalResponses, InsightTransferCategoryData, InsightTransferCategoryErrors, InsightTransferCategoryResponses, InsightTransferNoCategoryData, InsightTransferNoCategoryErrors, InsightTransferNoCategoryResponses, InsightTransferNoTagData, InsightTransferNoTagErrors, InsightTransferNoTagResponses, InsightTransfersData, InsightTransfersErrors, InsightTransfersResponses, InsightTransferTagData, InsightTransferTagErrors, InsightTransferTagResponses, InsightTransferTotalData, InsightTransferTotalErrors, InsightTransferTotalResponses, ListAccountByCurrencyData, ListAccountByCurrencyErrors, ListAccountByCurrencyResponses, ListAccountData, ListAccountErrors, ListAccountResponses, ListAttachmentByAccountData, ListAttachmentByAccountErrors, ListAttachmentByAccountResponses, ListAttachmentByBillData, ListAttachmentByBillErrors, ListAttachmentByBillResponses, ListAttachmentByBudgetData, ListAttachmentByBudgetErrors, ListAttachmentByBudgetResponses, ListAttachmentByCategoryData, ListAttachmentByCategoryErrors, ListAttachmentByCategoryResponses, ListAttachmentByPiggyBankData, ListAttachmentByPiggyBankErrors, ListAttachmentByPiggyBankResponses, ListAttachmentByTagData, ListAttachmentByTagErrors, ListAttachmentByTagResponses, ListAttachmentByTransactionData, ListAttachmentByTransactionErrors, ListAttachmentByTransactionResponses, ListAttachmentData, ListAttachmentErrors, ListAttachmentResponses, ListAvailableBudgetByCurrencyData, ListAvailableBudgetByCurrencyErrors, ListAvailableBudgetByCurrencyResponses, ListAvailableBudgetsData, ListAvailableBudgetsErrors, ListAvailableBudgetsResponses, ListBillByCurrencyData, ListBillByCurrencyErrors, ListBillByCurrencyResponses, ListBillByObjectGroupData, ListBillByObjectGroupErrors, ListBillByObjectGroupResponses, ListBillData, ListBillErrors, ListBillResponses, ListBudgetData, ListBudgetErrors, ListBudgetLimitByBudgetData, ListBudgetLimitByBudgetErrors, ListBudgetLimitByBudgetResponses, ListBudgetLimitByCurrencyData, ListBudgetLimitByCurrencyErrors, ListBudgetLimitByCurrencyResponses, ListBudgetLimitData, ListBudgetLimitErrors, ListBudgetLimitResponses, ListBudgetResponses, ListCategoryData, ListCategoryErrors, ListCategoryResponses, ListCurrencyData, ListCurrencyErrors, ListCurrencyExchangeRatesData, ListCurrencyExchangeRatesErrors, ListCurrencyExchangeRatesResponses, ListCurrencyResponses, ListEventByPiggyBankData, ListEventByPiggyBankErrors, ListEventByPiggyBankResponses, ListEventByTransactionData, ListEventByTransactionErrors, ListEventByTransactionResponses, ListLinksByJournalData, ListLinksByJournalErrors, ListLinksByJournalResponses, ListLinkTypeData, ListLinkTypeErrors, ListLinkTypeResponses, ListObjectGroupsData, ListObjectGroupsErrors, ListObjectGroupsResponses, ListPiggyBankByAccountData, ListPiggyBankByAccountErrors, ListPiggyBankByAccountResponses, ListPiggyBankByObjectGroupData, ListPiggyBankByObjectGroupErrors, ListPiggyBankByObjectGroupResponses, ListPiggyBankData, ListPiggyBankErrors, ListPiggyBankResponses, ListPreferenceData, ListPreferenceErrors, ListPreferenceResponses, ListRecurrenceByCurrencyData, ListRecurrenceByCurrencyErrors, ListRecurrenceByCurrencyResponses, ListRecurrenceData, ListRecurrenceErrors, ListRecurrenceResponses, ListRuleByBillData, ListRuleByBillErrors, ListRuleByBillResponses, ListRuleByCurrencyData, ListRuleByCurrencyErrors, ListRuleByCurrencyResponses, ListRuleByGroupData, ListRuleByGroupErrors, ListRuleByGroupResponses, ListRuleData, ListRuleErrors, ListRuleGroupData, ListRuleGroupErrors, ListRuleGroupResponses, ListRuleResponses, ListSpecificCurrencyExchangeRateData, ListSpecificCurrencyExchangeRateErrors, ListSpecificCurrencyExchangeRateOnDateData, ListSpecificCurrencyExchangeRateOnDateErrors, ListSpecificCurrencyExchangeRateOnDateResponses, ListSpecificCurrencyExchangeRateResponses, ListSpecificCurrencyExchangeRatesData, ListSpecificCurrencyExchangeRatesErrors, ListSpecificCurrencyExchangeRatesResponses, ListTagData, ListTagErrors, ListTagResponses, ListTransactionByAccountData, ListTransactionByAccountErrors, ListTransactionByAccountResponses, ListTransactionByBillData, ListTransactionByBillErrors, ListTransactionByBillResponses, ListTransactionByBudgetData, ListTransactionByBudgetErrors, ListTransactionByBudgetLimitData, ListTransactionByBudgetLimitErrors, ListTransactionByBudgetLimitResponses, ListTransactionByBudgetResponses, ListTransactionByCategoryData, ListTransactionByCategoryErrors, ListTransactionByCategoryResponses, ListTransactionByCurrencyData, ListTransactionByCurrencyErrors, ListTransactionByCurrencyResponses, ListTransactionByLinkTypeData, ListTransactionByLinkTypeErrors, ListTransactionByLinkTypeResponses, ListTransactionByRecurrenceData, ListTransactionByRecurrenceErrors, ListTransactionByRecurrenceResponses, ListTransactionByTagData, ListTransactionByTagErrors, ListTransactionByTagResponses, ListTransactionData, ListTransactionErrors, ListTransactionLinkData, ListTransactionLinkErrors, ListTransactionLinkResponses, ListTransactionResponses, ListTransactionWithoutBudgetData, ListTransactionWithoutBudgetErrors, ListTransactionWithoutBudgetResponses, ListUserData, ListUserErrors, ListUserGroupsData, ListUserGroupsErrors, ListUserGroupsResponses, ListUserResponses, ListWebhookData, ListWebhookErrors, ListWebhookResponses, PrimaryCurrencyData, PrimaryCurrencyErrors, PrimaryCurrencyResponses, PurgeDataData, PurgeDataErrors, PurgeDataResponses, SearchAccountsData, SearchAccountsErrors, SearchAccountsResponses, SearchTransactionsData, SearchTransactionsErrors, SearchTransactionsResponses, SetConfigurationData, SetConfigurationErrors, SetConfigurationResponses, StoreAccountData, StoreAccountErrors, StoreAccountResponses, StoreAttachmentData, StoreAttachmentErrors, StoreAttachmentResponses, StoreBillData, StoreBillErrors, StoreBillResponses, StoreBudgetData, StoreBudgetErrors, StoreBudgetLimitData, StoreBudgetLimitErrors, StoreBudgetLimitResponses, StoreBudgetResponses, StoreCategoryData, StoreCategoryErrors, StoreCategoryResponses, StoreCurrencyData, StoreCurrencyErrors, StoreCurrencyExchangeRateData, StoreCurrencyExchangeRateErrors, StoreCurrencyExchangeRateResponses, StoreCurrencyExchangeRatesByDateData, StoreCurrencyExchangeRatesByDateErrors, StoreCurrencyExchangeRatesByDateResponses, StoreCurrencyExchangeRatesByPairData, StoreCurrencyExchangeRatesByPairErrors, StoreCurrencyExchangeRatesByPairResponses, StoreCurrencyResponses, StoreLinkTypeData, StoreLinkTypeErrors, StoreLinkTypeResponses, StorePiggyBankData, StorePiggyBankErrors, StorePiggyBankResponses, StorePreferenceData, StorePreferenceErrors, StorePreferenceResponses, StoreRecurrenceData, StoreRecurrenceErrors, StoreRecurrenceResponses, StoreRuleData, StoreRuleErrors, StoreRuleGroupData, StoreRuleGroupErrors, StoreRuleGroupResponses, StoreRuleResponses, StoreTagData, StoreTagErrors, StoreTagResponses, StoreTransactionData, StoreTransactionErrors, StoreTransactionLinkData, StoreTransactionLinkErrors, StoreTransactionLinkResponses, StoreTransactionResponses, StoreUserData, StoreUserErrors, StoreUserResponses, StoreWebhookData, StoreWebhookErrors, StoreWebhookResponses, SubmitWebhookData, SubmitWebhookErrors, SubmitWebhookResponses, TestRuleData, TestRuleErrors, TestRuleGroupData, TestRuleGroupErrors, TestRuleGroupResponses, TestRuleResponses, TriggerRecurrenceRecurrenceData, TriggerRecurrenceRecurrenceErrors, TriggerRecurrenceRecurrenceResponses, TriggerTransactionWebhookData, TriggerTransactionWebhookErrors, TriggerTransactionWebhookResponses, UpdateAccountData, UpdateAccountErrors, UpdateAccountResponses, UpdateAttachmentData, UpdateAttachmentErrors, UpdateAttachmentResponses, UpdateBillData, UpdateBillErrors, UpdateBillResponses, UpdateBudgetData, UpdateBudgetErrors, UpdateBudgetLimitData, UpdateBudgetLimitErrors, UpdateBudgetLimitResponses, UpdateBudgetResponses, UpdateCategoryData, UpdateCategoryErrors, UpdateCategoryResponses, UpdateCurrencyData, UpdateCurrencyErrors, UpdateCurrencyExchangeRateByDateData, UpdateCurrencyExchangeRateByDateErrors, UpdateCurrencyExchangeRateByDateResponses, UpdateCurrencyExchangeRateData, UpdateCurrencyExchangeRateErrors, UpdateCurrencyExchangeRateResponses, UpdateCurrencyResponses, UpdateLinkTypeData, UpdateLinkTypeErrors, UpdateLinkTypeResponses, UpdateObjectGroupData, UpdateObjectGroupErrors, UpdateObjectGroupResponses, UpdatePiggyBankData, UpdatePiggyBankErrors, UpdatePiggyBankResponses, UpdatePreferenceData, UpdatePreferenceErrors, UpdatePreferenceResponses, UpdateRecurrenceData, UpdateRecurrenceErrors, UpdateRecurrenceResponses, UpdateRuleData, UpdateRuleErrors, UpdateRuleGroupData, UpdateRuleGroupErrors, UpdateRuleGroupResponses, UpdateRuleResponses, UpdateTagData, UpdateTagErrors, UpdateTagResponses, UpdateTransactionData, UpdateTransactionErrors, UpdateTransactionLinkData, UpdateTransactionLinkErrors, UpdateTransactionLinkResponses, UpdateTransactionResponses, UpdateUserData, UpdateUserErrors, UpdateUserGroupData, UpdateUserGroupErrors, UpdateUserGroupResponses, UpdateUserResponses, UpdateWebhookData, UpdateWebhookErrors, UpdateWebhookResponses, UploadAttachmentData, UploadAttachmentErrors, UploadAttachmentResponses } from './types.gen.js';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Returns all accounts of the user returned in a basic auto-complete array.
 */
export const getAccountsAc = <ThrowOnError extends boolean = false>(options?: Options<GetAccountsAcData, ThrowOnError>) => (options?.client ?? client).get<GetAccountsAcResponses, GetAccountsAcErrors, ThrowOnError>({
    querySerializer: { parameters: { types: { array: { explode: false } } } },
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/accounts',
    ...options
});

/**
 * Returns all bills of the user returned in a basic auto-complete array.
 */
export const getBillsAc = <ThrowOnError extends boolean = false>(options?: Options<GetBillsAcData, ThrowOnError>) => (options?.client ?? client).get<GetBillsAcResponses, GetBillsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/bills',
    ...options
});

/**
 * Returns all budgets of the user returned in a basic auto-complete array.
 */
export const getBudgetsAc = <ThrowOnError extends boolean = false>(options?: Options<GetBudgetsAcData, ThrowOnError>) => (options?.client ?? client).get<GetBudgetsAcResponses, GetBudgetsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/budgets',
    ...options
});

/**
 * Returns all categories of the user returned in a basic auto-complete array.
 */
export const getCategoriesAc = <ThrowOnError extends boolean = false>(options?: Options<GetCategoriesAcData, ThrowOnError>) => (options?.client ?? client).get<GetCategoriesAcResponses, GetCategoriesAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/categories',
    ...options
});

/**
 * Returns all currencies of the user returned in a basic auto-complete array.
 */
export const getCurrenciesAc = <ThrowOnError extends boolean = false>(options?: Options<GetCurrenciesAcData, ThrowOnError>) => (options?.client ?? client).get<GetCurrenciesAcResponses, GetCurrenciesAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/currencies',
    ...options
});

/**
 * Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
 */
export const getCurrenciesCodeAc = <ThrowOnError extends boolean = false>(options?: Options<GetCurrenciesCodeAcData, ThrowOnError>) => (options?.client ?? client).get<GetCurrenciesCodeAcResponses, GetCurrenciesCodeAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/currencies-with-code',
    ...options
});

/**
 * Returns all object groups of the user returned in a basic auto-complete array.
 */
export const getObjectGroupsAc = <ThrowOnError extends boolean = false>(options?: Options<GetObjectGroupsAcData, ThrowOnError>) => (options?.client ?? client).get<GetObjectGroupsAcResponses, GetObjectGroupsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/object-groups',
    ...options
});

/**
 * Returns all piggy banks of the user returned in a basic auto-complete array.
 */
export const getPiggiesAc = <ThrowOnError extends boolean = false>(options?: Options<GetPiggiesAcData, ThrowOnError>) => (options?.client ?? client).get<GetPiggiesAcResponses, GetPiggiesAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/piggy-banks',
    ...options
});

/**
 * Returns all piggy banks of the user returned in a basic auto-complete array.
 */
export const getPiggiesBalanceAc = <ThrowOnError extends boolean = false>(options?: Options<GetPiggiesBalanceAcData, ThrowOnError>) => (options?.client ?? client).get<GetPiggiesBalanceAcResponses, GetPiggiesBalanceAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/piggy-banks-with-balance',
    ...options
});

/**
 * Returns all recurring transactions of the user returned in a basic auto-complete array.
 */
export const getRecurringAc = <ThrowOnError extends boolean = false>(options?: Options<GetRecurringAcData, ThrowOnError>) => (options?.client ?? client).get<GetRecurringAcResponses, GetRecurringAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/recurring',
    ...options
});

/**
 * Returns all rule groups of the user returned in a basic auto-complete array.
 */
export const getRuleGroupsAc = <ThrowOnError extends boolean = false>(options?: Options<GetRuleGroupsAcData, ThrowOnError>) => (options?.client ?? client).get<GetRuleGroupsAcResponses, GetRuleGroupsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/rule-groups',
    ...options
});

/**
 * Returns all rules of the user returned in a basic auto-complete array.
 */
export const getRulesAc = <ThrowOnError extends boolean = false>(options?: Options<GetRulesAcData, ThrowOnError>) => (options?.client ?? client).get<GetRulesAcResponses, GetRulesAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/rules',
    ...options
});

/**
 * Returns all subscriptions of the user returned in a basic auto-complete array.
 */
export const getSubscriptionsAc = <ThrowOnError extends boolean = false>(options?: Options<GetSubscriptionsAcData, ThrowOnError>) => (options?.client ?? client).get<GetSubscriptionsAcResponses, GetSubscriptionsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/subscriptions',
    ...options
});

/**
 * Returns all tags of the user returned in a basic auto-complete array.
 */
export const getTagAc = <ThrowOnError extends boolean = false>(options?: Options<GetTagAcData, ThrowOnError>) => (options?.client ?? client).get<GetTagAcResponses, GetTagAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/tags',
    ...options
});

/**
 * Returns all transaction types returned in a basic auto-complete array. English only.
 */
export const getTransactionTypesAc = <ThrowOnError extends boolean = false>(options?: Options<GetTransactionTypesAcData, ThrowOnError>) => (options?.client ?? client).get<GetTransactionTypesAcResponses, GetTransactionTypesAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/transaction-types',
    ...options
});

/**
 * Returns all transaction descriptions of the user returned in a basic auto-complete array.
 */
export const getTransactionsAc = <ThrowOnError extends boolean = false>(options?: Options<GetTransactionsAcData, ThrowOnError>) => (options?.client ?? client).get<GetTransactionsAcResponses, GetTransactionsAcErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/transactions',
    ...options
});

/**
 * Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
 */
export const getTransactionsIdac = <ThrowOnError extends boolean = false>(options?: Options<GetTransactionsIdacData, ThrowOnError>) => (options?.client ?? client).get<GetTransactionsIdacResponses, GetTransactionsIdacErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/autocomplete/transactions-with-id',
    ...options
});

/**
 * Dashboard chart with asset account balance information.
 *
 * This endpoint returns the data required to generate a chart with basic asset account balance information. This is used on the dashboard.
 *
 */
export const getChartAccountOverview = <ThrowOnError extends boolean = false>(options: Options<GetChartAccountOverviewData, ThrowOnError>) => (options.client ?? client).get<GetChartAccountOverviewResponses, GetChartAccountOverviewErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/chart/account/overview',
    ...options
});

/**
 * Dashboard chart with balance information.
 *
 * This endpoint returns the data required to generate a chart with balance information.
 *
 */
export const getChartBalance = <ThrowOnError extends boolean = false>(options: Options<GetChartBalanceData, ThrowOnError>) => (options.client ?? client).get<GetChartBalanceResponses, GetChartBalanceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/chart/balance/balance',
    ...options
});

/**
 * Dashboard chart with budget information.
 *
 * This endpoint returns the data required to generate a chart with basic budget information.
 *
 */
export const getChartBudgetOverview = <ThrowOnError extends boolean = false>(options: Options<GetChartBudgetOverviewData, ThrowOnError>) => (options.client ?? client).get<GetChartBudgetOverviewResponses, GetChartBudgetOverviewErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/chart/budget/overview',
    ...options
});

/**
 * Dashboard chart with category information.
 *
 * This endpoint returns the data required to generate a chart with basic category information.
 *
 */
export const getChartCategoryOverview = <ThrowOnError extends boolean = false>(options: Options<GetChartCategoryOverviewData, ThrowOnError>) => (options.client ?? client).get<GetChartCategoryOverviewResponses, GetChartCategoryOverviewErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/chart/category/overview',
    ...options
});

/**
 * Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
 *
 * Allows you to update transactions in bulk.
 *
 */
export const bulkUpdateTransactions = <ThrowOnError extends boolean = false>(options: Options<BulkUpdateTransactionsData, ThrowOnError>) => (options.client ?? client).post<BulkUpdateTransactionsResponses, BulkUpdateTransactionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/bulk/transactions',
    ...options
});

/**
 * Endpoint to destroy user data
 *
 * A call to this endpoint deletes the requested data type. Use it with care and always with user permission.
 * The demo user is incapable of using this endpoint.
 *
 */
export const destroyData = <ThrowOnError extends boolean = false>(options: Options<DestroyDataData, ThrowOnError>) => (options.client ?? client).delete<DestroyDataResponses, DestroyDataErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/destroy',
    ...options
});

/**
 * Export account data from Firefly III
 *
 * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportAccounts = <ThrowOnError extends boolean = false>(options?: Options<ExportAccountsData, ThrowOnError>) => (options?.client ?? client).get<ExportAccountsResponses, ExportAccountsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/accounts',
    ...options
});

/**
 * Export bills from Firefly III
 *
 * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportBills = <ThrowOnError extends boolean = false>(options?: Options<ExportBillsData, ThrowOnError>) => (options?.client ?? client).get<ExportBillsResponses, ExportBillsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/bills',
    ...options
});

/**
 * Export budgets and budget amount data from Firefly III
 *
 * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportBudgets = <ThrowOnError extends boolean = false>(options?: Options<ExportBudgetsData, ThrowOnError>) => (options?.client ?? client).get<ExportBudgetsResponses, ExportBudgetsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/budgets',
    ...options
});

/**
 * Export category data from Firefly III
 *
 * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportCategories = <ThrowOnError extends boolean = false>(options?: Options<ExportCategoriesData, ThrowOnError>) => (options?.client ?? client).get<ExportCategoriesResponses, ExportCategoriesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/categories',
    ...options
});

/**
 * Export piggy banks from Firefly III
 *
 * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportPiggies = <ThrowOnError extends boolean = false>(options?: Options<ExportPiggiesData, ThrowOnError>) => (options?.client ?? client).get<ExportPiggiesResponses, ExportPiggiesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/piggy-banks',
    ...options
});

/**
 * Export recurring transaction data from Firefly III
 *
 * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportRecurring = <ThrowOnError extends boolean = false>(options?: Options<ExportRecurringData, ThrowOnError>) => (options?.client ?? client).get<ExportRecurringResponses, ExportRecurringErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/recurring',
    ...options
});

/**
 * Export rule groups and rule data from Firefly III
 *
 * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportRules = <ThrowOnError extends boolean = false>(options?: Options<ExportRulesData, ThrowOnError>) => (options?.client ?? client).get<ExportRulesResponses, ExportRulesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/rules',
    ...options
});

/**
 * Export tag data from Firefly III
 *
 * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportTags = <ThrowOnError extends boolean = false>(options?: Options<ExportTagsData, ThrowOnError>) => (options?.client ?? client).get<ExportTagsResponses, ExportTagsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/tags',
    ...options
});

/**
 * Export transaction data from Firefly III
 *
 * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only.
 *
 */
export const exportTransactions = <ThrowOnError extends boolean = false>(options: Options<ExportTransactionsData, ThrowOnError>) => (options.client ?? client).get<ExportTransactionsResponses, ExportTransactionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/export/transactions',
    ...options
});

/**
 * Endpoint to purge user data
 *
 * A call to this endpoint purges all previously deleted data. Use it with care and always with user permission.
 * The demo user is incapable of using this endpoint.
 *
 */
export const purgeData = <ThrowOnError extends boolean = false>(options?: Options<PurgeDataData, ThrowOnError>) => (options?.client ?? client).delete<PurgeDataResponses, PurgeDataErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/data/purge',
    ...options
});

/**
 * Insight into expenses, grouped by expense account.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by expense account.
 *
 */
export const insightExpenseExpense = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseExpenseData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseExpenseResponses, InsightExpenseExpenseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/expense',
    ...options
});

/**
 * Insight into expenses, grouped by asset account.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by asset account.
 *
 */
export const insightExpenseAsset = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseAssetData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseAssetResponses, InsightExpenseAssetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/asset',
    ...options
});

/**
 * Insight into income, grouped by revenue account.
 *
 * This endpoint gives a summary of the income received by the user, grouped by revenue account.
 *
 */
export const insightIncomeRevenue = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeRevenueData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeRevenueResponses, InsightIncomeRevenueErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/revenue',
    ...options
});

/**
 * Insight into income, grouped by asset account.
 *
 * This endpoint gives a summary of the income received by the user, grouped by asset account.
 *
 */
export const insightIncomeAsset = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeAssetData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeAssetResponses, InsightIncomeAssetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/asset',
    ...options
});

/**
 * Insight into transfers, grouped by account.
 *
 * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.
 *
 */
export const insightTransfers = <ThrowOnError extends boolean = false>(options: Options<InsightTransfersData, ThrowOnError>) => (options.client ?? client).get<InsightTransfersResponses, InsightTransfersErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/asset',
    ...options
});

/**
 * Insight into expenses, grouped by bill.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.
 *
 */
export const insightExpenseBill = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseBillData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseBillResponses, InsightExpenseBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/bill',
    ...options
});

/**
 * Insight into expenses, without bill.
 *
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.
 *
 */
export const insightExpenseNoBill = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseNoBillData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseNoBillResponses, InsightExpenseNoBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/no-bill',
    ...options
});

/**
 * Insight into expenses, grouped by budget.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.
 *
 */
export const insightExpenseBudget = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseBudgetData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseBudgetResponses, InsightExpenseBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/budget',
    ...options
});

/**
 * Insight into expenses, without budget.
 *
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.
 *
 */
export const insightExpenseNoBudget = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseNoBudgetData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseNoBudgetResponses, InsightExpenseNoBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/no-budget',
    ...options
});

/**
 * Insight into expenses, grouped by category.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.
 *
 */
export const insightExpenseCategory = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseCategoryResponses, InsightExpenseCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/category',
    ...options
});

/**
 * Insight into expenses, without category.
 *
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.
 *
 */
export const insightExpenseNoCategory = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseNoCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseNoCategoryResponses, InsightExpenseNoCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/no-category',
    ...options
});

/**
 * Insight into income, grouped by category.
 *
 * This endpoint gives a summary of the income received by the user, grouped by (any) category.
 *
 */
export const insightIncomeCategory = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeCategoryResponses, InsightIncomeCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/category',
    ...options
});

/**
 * Insight into income, without category.
 *
 * This endpoint gives a summary of the income received by the user, including only income with no category.
 *
 */
export const insightIncomeNoCategory = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeNoCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeNoCategoryResponses, InsightIncomeNoCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/no-category',
    ...options
});

/**
 * Insight into transfers, grouped by category.
 *
 * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.
 *
 */
export const insightTransferCategory = <ThrowOnError extends boolean = false>(options: Options<InsightTransferCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightTransferCategoryResponses, InsightTransferCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/category',
    ...options
});

/**
 * Insight into transfers, without category.
 *
 * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.
 *
 */
export const insightTransferNoCategory = <ThrowOnError extends boolean = false>(options: Options<InsightTransferNoCategoryData, ThrowOnError>) => (options.client ?? client).get<InsightTransferNoCategoryResponses, InsightTransferNoCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/no-category',
    ...options
});

/**
 * Insight into expenses, grouped by tag.
 *
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.
 *
 */
export const insightExpenseTag = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseTagData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseTagResponses, InsightExpenseTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/tag',
    ...options
});

/**
 * Insight into expenses, without tag.
 *
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.
 *
 */
export const insightExpenseNoTag = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseNoTagData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseNoTagResponses, InsightExpenseNoTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/no-tag',
    ...options
});

/**
 * Insight into income, grouped by tag.
 *
 * This endpoint gives a summary of the income received by the user, grouped by (any) tag.
 *
 */
export const insightIncomeTag = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeTagData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeTagResponses, InsightIncomeTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/tag',
    ...options
});

/**
 * Insight into income, without tag.
 *
 * This endpoint gives a summary of the income received by the user, including only income with no tag.
 *
 */
export const insightIncomeNoTag = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeNoTagData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeNoTagResponses, InsightIncomeNoTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/no-tag',
    ...options
});

/**
 * Insight into transfers, grouped by tag.
 *
 * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.
 *
 */
export const insightTransferTag = <ThrowOnError extends boolean = false>(options: Options<InsightTransferTagData, ThrowOnError>) => (options.client ?? client).get<InsightTransferTagResponses, InsightTransferTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/tag',
    ...options
});

/**
 * Insight into expenses, without tag.
 *
 * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.
 *
 */
export const insightTransferNoTag = <ThrowOnError extends boolean = false>(options: Options<InsightTransferNoTagData, ThrowOnError>) => (options.client ?? client).get<InsightTransferNoTagResponses, InsightTransferNoTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/no-tag',
    ...options
});

/**
 * Insight into total expenses.
 *
 * This endpoint gives a sum of the total expenses made by the user.
 *
 */
export const insightExpenseTotal = <ThrowOnError extends boolean = false>(options: Options<InsightExpenseTotalData, ThrowOnError>) => (options.client ?? client).get<InsightExpenseTotalResponses, InsightExpenseTotalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/expense/total',
    ...options
});

/**
 * Insight into total income.
 *
 * This endpoint gives a sum of the total income received by the user.
 *
 */
export const insightIncomeTotal = <ThrowOnError extends boolean = false>(options: Options<InsightIncomeTotalData, ThrowOnError>) => (options.client ?? client).get<InsightIncomeTotalResponses, InsightIncomeTotalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/income/total',
    ...options
});

/**
 * Insight into total transfers.
 *
 * This endpoint gives a sum of the total amount transfers made by the user.
 *
 */
export const insightTransferTotal = <ThrowOnError extends boolean = false>(options: Options<InsightTransferTotalData, ThrowOnError>) => (options.client ?? client).get<InsightTransferTotalResponses, InsightTransferTotalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/insight/transfer/total',
    ...options
});

/**
 * List all transactions related to the account.
 *
 * This endpoint returns a list of all the transactions connected to the account.
 *
 */
export const listTransactionByAccount = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByAccountData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByAccountResponses, ListTransactionByAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}/transactions',
    ...options
});

/**
 * Lists all attachments.
 *
 * Lists all attachments.
 */
export const listAttachmentByAccount = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByAccountData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByAccountResponses, ListAttachmentByAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}/attachments',
    ...options
});

/**
 * List all piggy banks related to the account.
 *
 * This endpoint returns a list of all the piggy banks connected to the account.
 *
 */
export const listPiggyBankByAccount = <ThrowOnError extends boolean = false>(options: Options<ListPiggyBankByAccountData, ThrowOnError>) => (options.client ?? client).get<ListPiggyBankByAccountResponses, ListPiggyBankByAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}/piggy-banks',
    ...options
});

/**
 * List all accounts.
 *
 * This endpoint returns a list of all the accounts owned by the authenticated user.
 *
 */
export const listAccount = <ThrowOnError extends boolean = false>(options?: Options<ListAccountData, ThrowOnError>) => (options?.client ?? client).get<ListAccountResponses, ListAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts',
    ...options
});

/**
 * Create new account.
 *
 * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
 */
export const storeAccount = <ThrowOnError extends boolean = false>(options: Options<StoreAccountData, ThrowOnError>) => (options.client ?? client).post<StoreAccountResponses, StoreAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete account.
 *
 * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from.
 *
 */
export const deleteAccount = <ThrowOnError extends boolean = false>(options: Options<DeleteAccountData, ThrowOnError>) => (options.client ?? client).delete<DeleteAccountResponses, DeleteAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}',
    ...options
});

/**
 * Get single account.
 *
 * Returns a single account by its ID.
 *
 */
export const getAccount = <ThrowOnError extends boolean = false>(options: Options<GetAccountData, ThrowOnError>) => (options.client ?? client).get<GetAccountResponses, GetAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}',
    ...options
});

/**
 * Update existing account.
 *
 * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory.
 *
 */
export const updateAccount = <ThrowOnError extends boolean = false>(options: Options<UpdateAccountData, ThrowOnError>) => (options.client ?? client).put<UpdateAccountResponses, UpdateAccountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/accounts/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all attachments.
 *
 * This endpoint lists all attachments.
 *
 */
export const listAttachment = <ThrowOnError extends boolean = false>(options?: Options<ListAttachmentData, ThrowOnError>) => (options?.client ?? client).get<ListAttachmentResponses, ListAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments',
    ...options
});

/**
 * Store a new attachment.
 *
 * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object.
 *
 */
export const storeAttachment = <ThrowOnError extends boolean = false>(options: Options<StoreAttachmentData, ThrowOnError>) => (options.client ?? client).post<StoreAttachmentResponses, StoreAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete an attachment.
 *
 * With this endpoint you delete an attachment, including any stored file data.
 *
 */
export const deleteAttachment = <ThrowOnError extends boolean = false>(options: Options<DeleteAttachmentData, ThrowOnError>) => (options.client ?? client).delete<DeleteAttachmentResponses, DeleteAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments/{id}',
    ...options
});

/**
 * Get a single attachment.
 *
 * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below).
 *
 */
export const getAttachment = <ThrowOnError extends boolean = false>(options: Options<GetAttachmentData, ThrowOnError>) => (options.client ?? client).get<GetAttachmentResponses, GetAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments/{id}',
    ...options
});

/**
 * Update existing attachment.
 *
 * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below.
 *
 */
export const updateAttachment = <ThrowOnError extends boolean = false>(options: Options<UpdateAttachmentData, ThrowOnError>) => (options.client ?? client).put<UpdateAttachmentResponses, UpdateAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Download a single attachment.
 *
 * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type "application/octet-stream" and content disposition "attachment; filename=example.pdf".
 *
 */
export const downloadAttachment = <ThrowOnError extends boolean = false>(options: Options<DownloadAttachmentData, ThrowOnError>) => (options.client ?? client).get<DownloadAttachmentResponses, DownloadAttachmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments/{id}/download',
    ...options
});

/**
 * Upload an attachment.
 *
 * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data.
 *
 */
export const uploadAttachment = <ThrowOnError extends boolean = false>(options: Options<UploadAttachmentData, ThrowOnError>) => (options.client ?? client).post<UploadAttachmentResponses, UploadAttachmentErrors, ThrowOnError>({
    bodySerializer: null,
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/attachments/{id}/upload',
    ...options,
    headers: {
        'Content-Type': 'application/octet-stream',
        ...options.headers
    }
});

/**
 * List all available budget amounts.
 *
 * Firefly III calculates the total amount of money budgeted in so-called "available budgets". This endpoint returns all of these amounts and the periods for which they are calculated.
 *
 */
export const listAvailableBudgets = <ThrowOnError extends boolean = false>(options?: Options<ListAvailableBudgetsData, ThrowOnError>) => (options?.client ?? client).get<ListAvailableBudgetsResponses, ListAvailableBudgetsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/available-budgets',
    ...options
});

/**
 * Get a single available budget.
 *
 * Get a single available budget, by ID.
 */
export const getAvailableBudget = <ThrowOnError extends boolean = false>(options: Options<GetAvailableBudgetData, ThrowOnError>) => (options.client ?? client).get<GetAvailableBudgetResponses, GetAvailableBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/available-budgets/{id}',
    ...options
});

/**
 * List all attachments uploaded to the bill.
 *
 * This endpoint will list all attachments linked to the bill.
 */
export const listAttachmentByBill = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByBillData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByBillResponses, ListAttachmentByBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}/attachments',
    ...options
});

/**
 * List all rules associated with the bill.
 *
 * This endpoint will list all rules that have an action to set the bill to this bill.
 */
export const listRuleByBill = <ThrowOnError extends boolean = false>(options: Options<ListRuleByBillData, ThrowOnError>) => (options.client ?? client).get<ListRuleByBillResponses, ListRuleByBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}/rules',
    ...options
});

/**
 * List all transactions associated with the  bill.
 *
 * This endpoint will list all transactions linked to this bill.
 */
export const listTransactionByBill = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByBillData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByBillResponses, ListTransactionByBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}/transactions',
    ...options
});

/**
 * List all bills.
 *
 * This endpoint will list all the user's bills.
 */
export const listBill = <ThrowOnError extends boolean = false>(options?: Options<ListBillData, ThrowOnError>) => (options?.client ?? client).get<ListBillResponses, ListBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills',
    ...options
});

/**
 * Store a new bill
 *
 * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeBill = <ThrowOnError extends boolean = false>(options: Options<StoreBillData, ThrowOnError>) => (options.client ?? client).post<StoreBillResponses, StoreBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a bill.
 *
 * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
 */
export const deleteBill = <ThrowOnError extends boolean = false>(options: Options<DeleteBillData, ThrowOnError>) => (options.client ?? client).delete<DeleteBillResponses, DeleteBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}',
    ...options
});

/**
 * Get a single bill.
 *
 * Get a single bill.
 */
export const getBill = <ThrowOnError extends boolean = false>(options: Options<GetBillData, ThrowOnError>) => (options.client ?? client).get<GetBillResponses, GetBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}',
    ...options
});

/**
 * Update existing bill.
 *
 * Update existing bill.
 */
export const updateBill = <ThrowOnError extends boolean = false>(options: Options<UpdateBillData, ThrowOnError>) => (options.client ?? client).put<UpdateBillResponses, UpdateBillErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/bills/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all transactions by a budget limit ID.
 *
 * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
 */
export const listTransactionByBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByBudgetLimitData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByBudgetLimitResponses, ListTransactionByBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits/{limitId}/transactions',
    ...options
});

/**
 * Get all limits for a budget.
 *
 * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The "spent" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.
 *
 */
export const listBudgetLimitByBudget = <ThrowOnError extends boolean = false>(options: Options<ListBudgetLimitByBudgetData, ThrowOnError>) => (options.client ?? client).get<ListBudgetLimitByBudgetResponses, ListBudgetLimitByBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits',
    ...options
});

/**
 * Store new budget limit.
 *
 * Store a new budget limit under this budget.
 */
export const storeBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<StoreBudgetLimitData, ThrowOnError>) => (options.client ?? client).post<StoreBudgetLimitResponses, StoreBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a budget limit.
 *
 * Delete a budget limit.
 */
export const deleteBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<DeleteBudgetLimitData, ThrowOnError>) => (options.client ?? client).delete<DeleteBudgetLimitResponses, DeleteBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits/{limitId}',
    ...options
});

/**
 * Get single budget limit.
 */
export const getBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<GetBudgetLimitData, ThrowOnError>) => (options.client ?? client).get<GetBudgetLimitResponses, GetBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits/{limitId}',
    ...options
});

/**
 * Update existing budget limit.
 *
 * Update existing budget limit.
 */
export const updateBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<UpdateBudgetLimitData, ThrowOnError>) => (options.client ?? client).put<UpdateBudgetLimitResponses, UpdateBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/limits/{limitId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get list of budget limits by date
 *
 * Get all budget limits for for this date range.
 *
 */
export const listBudgetLimit = <ThrowOnError extends boolean = false>(options: Options<ListBudgetLimitData, ThrowOnError>) => (options.client ?? client).get<ListBudgetLimitResponses, ListBudgetLimitErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budget-limits',
    ...options
});

/**
 * All transactions to a budget.
 *
 * Get all transactions linked to a budget, possibly limited by start and end
 */
export const listTransactionByBudget = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByBudgetData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByBudgetResponses, ListTransactionByBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/transactions',
    ...options
});

/**
 * Lists all attachments of a budget.
 *
 * Lists all attachments.
 */
export const listAttachmentByBudget = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByBudgetData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByBudgetResponses, ListAttachmentByBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}/attachments',
    ...options
});

/**
 * All transactions without a budget.
 *
 * Get all transactions NOT linked to a budget, possibly limited by start and end
 */
export const listTransactionWithoutBudget = <ThrowOnError extends boolean = false>(options?: Options<ListTransactionWithoutBudgetData, ThrowOnError>) => (options?.client ?? client).get<ListTransactionWithoutBudgetResponses, ListTransactionWithoutBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/transactions-without-budget',
    ...options
});

/**
 * List all budgets.
 *
 * List all the budgets the user has made. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
 */
export const listBudget = <ThrowOnError extends boolean = false>(options?: Options<ListBudgetData, ThrowOnError>) => (options?.client ?? client).get<ListBudgetResponses, ListBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets',
    ...options
});

/**
 * Store a new budget
 *
 * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeBudget = <ThrowOnError extends boolean = false>(options: Options<StoreBudgetData, ThrowOnError>) => (options.client ?? client).post<StoreBudgetResponses, StoreBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a budget.
 *
 * Delete a budget. Transactions will not be deleted.
 */
export const deleteBudget = <ThrowOnError extends boolean = false>(options: Options<DeleteBudgetData, ThrowOnError>) => (options.client ?? client).delete<DeleteBudgetResponses, DeleteBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}',
    ...options
});

/**
 * Get a single budget.
 *
 * Get a single budget. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
 */
export const getBudget = <ThrowOnError extends boolean = false>(options: Options<GetBudgetData, ThrowOnError>) => (options.client ?? client).get<GetBudgetResponses, GetBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}',
    ...options
});

/**
 * Update existing budget.
 *
 * Update existing budget. This endpoint cannot be used to set budget amount limits.
 */
export const updateBudget = <ThrowOnError extends boolean = false>(options: Options<UpdateBudgetData, ThrowOnError>) => (options.client ?? client).put<UpdateBudgetResponses, UpdateBudgetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/budgets/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all transactions in a category.
 *
 * List all transactions in a category, optionally limited to the date ranges specified.
 */
export const listTransactionByCategory = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByCategoryData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByCategoryResponses, ListTransactionByCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories/{id}/transactions',
    ...options
});

/**
 * Lists all attachments.
 *
 * Lists all attachments.
 */
export const listAttachmentByCategory = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByCategoryData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByCategoryResponses, ListAttachmentByCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories/{id}/attachments',
    ...options
});

/**
 * List all categories.
 *
 * List all categories.
 */
export const listCategory = <ThrowOnError extends boolean = false>(options?: Options<ListCategoryData, ThrowOnError>) => (options?.client ?? client).get<ListCategoryResponses, ListCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories',
    ...options
});

/**
 * Store a new category
 *
 * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeCategory = <ThrowOnError extends boolean = false>(options: Options<StoreCategoryData, ThrowOnError>) => (options.client ?? client).post<StoreCategoryResponses, StoreCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a category.
 *
 * Delete a category. Transactions will not be removed.
 */
export const deleteCategory = <ThrowOnError extends boolean = false>(options: Options<DeleteCategoryData, ThrowOnError>) => (options.client ?? client).delete<DeleteCategoryResponses, DeleteCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories/{id}',
    ...options
});

/**
 * Get a single category.
 *
 * Get a single category.
 */
export const getCategory = <ThrowOnError extends boolean = false>(options: Options<GetCategoryData, ThrowOnError>) => (options.client ?? client).get<GetCategoryResponses, GetCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories/{id}',
    ...options
});

/**
 * Update existing category.
 *
 * Update existing category.
 */
export const updateCategory = <ThrowOnError extends boolean = false>(options: Options<UpdateCategoryData, ThrowOnError>) => (options.client ?? client).put<UpdateCategoryResponses, UpdateCategoryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/categories/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all exchange rates that Firefly III knows.
 *
 * List exchange rates that Firefly III knows.
 */
export const listCurrencyExchangeRates = <ThrowOnError extends boolean = false>(options?: Options<ListCurrencyExchangeRatesData, ThrowOnError>) => (options?.client ?? client).get<ListCurrencyExchangeRatesResponses, ListCurrencyExchangeRatesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates',
    ...options
});

/**
 * Store a new currency exchange rate.
 *
 * Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeCurrencyExchangeRate = <ThrowOnError extends boolean = false>(options: Options<StoreCurrencyExchangeRateData, ThrowOnError>) => (options.client ?? client).post<StoreCurrencyExchangeRateResponses, StoreCurrencyExchangeRateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a specific currency exchange rate.
 *
 * Delete a specific currency exchange rate by its internal ID.
 */
export const deleteSpecificCurrencyExchangeRate = <ThrowOnError extends boolean = false>(options: Options<DeleteSpecificCurrencyExchangeRateData, ThrowOnError>) => (options.client ?? client).delete<DeleteSpecificCurrencyExchangeRateResponses, DeleteSpecificCurrencyExchangeRateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{id}',
    ...options
});

/**
 * List a single specific exchange rate.
 *
 * List a single specific exchange rate by its ID.
 */
export const listSpecificCurrencyExchangeRate = <ThrowOnError extends boolean = false>(options: Options<ListSpecificCurrencyExchangeRateData, ThrowOnError>) => (options.client ?? client).get<ListSpecificCurrencyExchangeRateResponses, ListSpecificCurrencyExchangeRateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{id}',
    ...options
});

/**
 * Update existing currency exchange rate.
 *
 * Used to update a single currency exchange rate by its ID. Including the from/to currency is optional.
 *
 */
export const updateCurrencyExchangeRate = <ThrowOnError extends boolean = false>(options: Options<UpdateCurrencyExchangeRateData, ThrowOnError>) => (options.client ?? client).put<UpdateCurrencyExchangeRateResponses, UpdateCurrencyExchangeRateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Deletes ALL currency exchange rates from 'from' to 'to'.
 *
 * Deletes ALL currency exchange rates from 'from' to 'to'. It's important to know that the reverse exchange rates (from 'to' to 'from') will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
 */
export const deleteSpecificCurrencyExchangeRates = <ThrowOnError extends boolean = false>(options: Options<DeleteSpecificCurrencyExchangeRatesData, ThrowOnError>) => (options.client ?? client).delete<DeleteSpecificCurrencyExchangeRatesResponses, DeleteSpecificCurrencyExchangeRatesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{from}/{to}',
    ...options
});

/**
 * List all exchange rates from/to the mentioned currencies.
 *
 * List all exchange rates from/to the mentioned currencies.
 */
export const listSpecificCurrencyExchangeRates = <ThrowOnError extends boolean = false>(options: Options<ListSpecificCurrencyExchangeRatesData, ThrowOnError>) => (options.client ?? client).get<ListSpecificCurrencyExchangeRatesResponses, ListSpecificCurrencyExchangeRatesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{from}/{to}',
    ...options
});

/**
 * Delete the currency exchange rate from 'from' to 'to' on the specified date.
 *
 * Delete the currency exchange rate from 'from' to 'to' on the specified date.  It's important to know that the reverse exchange rate (from 'to' to 'from') will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
 */
export const deleteSpecificCurrencyExchangeRateOnDate = <ThrowOnError extends boolean = false>(options: Options<DeleteSpecificCurrencyExchangeRateOnDateData, ThrowOnError>) => (options.client ?? client).delete<DeleteSpecificCurrencyExchangeRateOnDateResponses, DeleteSpecificCurrencyExchangeRateOnDateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{from}/{to}/{date}',
    ...options
});

/**
 * List the exchange rate for the from and to-currency on the requested date.
 *
 * List the exchange rate for the from and to-currency on the requested date.
 */
export const listSpecificCurrencyExchangeRateOnDate = <ThrowOnError extends boolean = false>(options: Options<ListSpecificCurrencyExchangeRateOnDateData, ThrowOnError>) => (options.client ?? client).get<ListSpecificCurrencyExchangeRateOnDateResponses, ListSpecificCurrencyExchangeRateOnDateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{from}/{to}/{date}',
    ...options
});

/**
 * Update existing currency exchange rate.
 *
 * Used to update a single currency exchange rate by its currency codes and date
 *
 */
export const updateCurrencyExchangeRateByDate = <ThrowOnError extends boolean = false>(options: Options<UpdateCurrencyExchangeRateByDateData, ThrowOnError>) => (options.client ?? client).put<UpdateCurrencyExchangeRateByDateResponses, UpdateCurrencyExchangeRateByDateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/{from}/{to}/{date}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Store new currency exchange rates under this date
 *
 * Stores a new set of exchange rates. The date is fixed (in the URL parameter) and the data required can be submitted as a JSON body.
 */
export const storeCurrencyExchangeRatesByDate = <ThrowOnError extends boolean = false>(options: Options<StoreCurrencyExchangeRatesByDateData, ThrowOnError>) => (options.client ?? client).post<StoreCurrencyExchangeRatesByDateResponses, StoreCurrencyExchangeRatesByDateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/by-date/{date}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Store new currency exchange rates under this from/to pair.
 *
 * Stores a new set of exchange rates for this pair. The date is variable, and the data required can be submitted as a JSON body.
 */
export const storeCurrencyExchangeRatesByPair = <ThrowOnError extends boolean = false>(options: Options<StoreCurrencyExchangeRatesByPairData, ThrowOnError>) => (options.client ?? client).post<StoreCurrencyExchangeRatesByPairResponses, StoreCurrencyExchangeRatesByPairErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/exchange-rates/by-currencies/{from}/{to}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all transactions under this link type.
 *
 * List all transactions under this link type, both the inward and outward transactions.
 *
 */
export const listTransactionByLinkType = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByLinkTypeData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByLinkTypeResponses, ListTransactionByLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types/{id}/transactions',
    ...options
});

/**
 * List all types of links.
 *
 * List all the link types the system has. These include the default ones as well as any new ones.
 *
 */
export const listLinkType = <ThrowOnError extends boolean = false>(options?: Options<ListLinkTypeData, ThrowOnError>) => (options?.client ?? client).get<ListLinkTypeResponses, ListLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types',
    ...options
});

/**
 * Create a new link type
 *
 * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
 */
export const storeLinkType = <ThrowOnError extends boolean = false>(options: Options<StoreLinkTypeData, ThrowOnError>) => (options.client ?? client).post<StoreLinkTypeResponses, StoreLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete link type.
 *
 * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it.
 *
 */
export const deleteLinkType = <ThrowOnError extends boolean = false>(options: Options<DeleteLinkTypeData, ThrowOnError>) => (options.client ?? client).delete<DeleteLinkTypeResponses, DeleteLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types/{id}',
    ...options
});

/**
 * Get single a link type.
 *
 * Returns a single link type by its ID.
 *
 */
export const getLinkType = <ThrowOnError extends boolean = false>(options: Options<GetLinkTypeData, ThrowOnError>) => (options.client ?? client).get<GetLinkTypeResponses, GetLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types/{id}',
    ...options
});

/**
 * Update existing link type.
 *
 * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it.
 *
 */
export const updateLinkType = <ThrowOnError extends boolean = false>(options: Options<UpdateLinkTypeData, ThrowOnError>) => (options.client ?? client).put<UpdateLinkTypeResponses, UpdateLinkTypeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/link-types/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all transaction links.
 *
 * List all the transaction links.
 *
 */
export const listTransactionLink = <ThrowOnError extends boolean = false>(options?: Options<ListTransactionLinkData, ThrowOnError>) => (options?.client ?? client).get<ListTransactionLinkResponses, ListTransactionLinkErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-links',
    ...options
});

/**
 * Create a new link between transactions
 *
 * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
 */
export const storeTransactionLink = <ThrowOnError extends boolean = false>(options: Options<StoreTransactionLinkData, ThrowOnError>) => (options.client ?? client).post<StoreTransactionLinkResponses, StoreTransactionLinkErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-links',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete link between transactions.
 *
 * Will permanently delete link. Transactions remain.
 *
 */
export const deleteTransactionLink = <ThrowOnError extends boolean = false>(options: Options<DeleteTransactionLinkData, ThrowOnError>) => (options.client ?? client).delete<DeleteTransactionLinkResponses, DeleteTransactionLinkErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-links/{id}',
    ...options
});

/**
 * Get a single link.
 *
 * Returns a single link by its ID.
 *
 */
export const getTransactionLink = <ThrowOnError extends boolean = false>(options: Options<GetTransactionLinkData, ThrowOnError>) => (options.client ?? client).get<GetTransactionLinkResponses, GetTransactionLinkErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-links/{id}',
    ...options
});

/**
 * Update an existing link between transactions.
 *
 * Used to update a single existing link.
 *
 */
export const updateTransactionLink = <ThrowOnError extends boolean = false>(options: Options<UpdateTransactionLinkData, ThrowOnError>) => (options.client ?? client).put<UpdateTransactionLinkResponses, UpdateTransactionLinkErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-links/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all piggy banks related to the object group.
 *
 * This endpoint returns a list of all the piggy banks connected to the object group.
 *
 */
export const listPiggyBankByObjectGroup = <ThrowOnError extends boolean = false>(options: Options<ListPiggyBankByObjectGroupData, ThrowOnError>) => (options.client ?? client).get<ListPiggyBankByObjectGroupResponses, ListPiggyBankByObjectGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups/{id}/piggy-banks',
    ...options
});

/**
 * List all bills with this object group.
 *
 * List all bills with this object group.
 */
export const listBillByObjectGroup = <ThrowOnError extends boolean = false>(options: Options<ListBillByObjectGroupData, ThrowOnError>) => (options.client ?? client).get<ListBillByObjectGroupResponses, ListBillByObjectGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups/{id}/bills',
    ...options
});

/**
 * List all object groups.
 *
 * List all object groups.
 */
export const listObjectGroups = <ThrowOnError extends boolean = false>(options?: Options<ListObjectGroupsData, ThrowOnError>) => (options?.client ?? client).get<ListObjectGroupsResponses, ListObjectGroupsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups',
    ...options
});

/**
 * Delete a object group.
 *
 * Delete a object group.
 */
export const deleteObjectGroup = <ThrowOnError extends boolean = false>(options: Options<DeleteObjectGroupData, ThrowOnError>) => (options.client ?? client).delete<DeleteObjectGroupResponses, DeleteObjectGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups/{id}',
    ...options
});

/**
 * Get a single object group.
 *
 * Get a single object group.
 */
export const getObjectGroup = <ThrowOnError extends boolean = false>(options: Options<GetObjectGroupData, ThrowOnError>) => (options.client ?? client).get<GetObjectGroupResponses, GetObjectGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups/{id}',
    ...options
});

/**
 * Update existing object group.
 *
 * Update existing object group.
 */
export const updateObjectGroup = <ThrowOnError extends boolean = false>(options: Options<UpdateObjectGroupData, ThrowOnError>) => (options.client ?? client).put<UpdateObjectGroupResponses, UpdateObjectGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/object-groups/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all events linked to a piggy bank.
 *
 * List all events linked to a piggy bank (adding and removing money).
 */
export const listEventByPiggyBank = <ThrowOnError extends boolean = false>(options: Options<ListEventByPiggyBankData, ThrowOnError>) => (options.client ?? client).get<ListEventByPiggyBankResponses, ListEventByPiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks/{id}/events',
    ...options
});

/**
 * Lists all attachments.
 *
 * Lists all attachments.
 */
export const listAttachmentByPiggyBank = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByPiggyBankData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByPiggyBankResponses, ListAttachmentByPiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks/{id}/attachments',
    ...options
});

/**
 * List all piggy banks.
 *
 * List all piggy banks.
 */
export const listPiggyBank = <ThrowOnError extends boolean = false>(options?: Options<ListPiggyBankData, ThrowOnError>) => (options?.client ?? client).get<ListPiggyBankResponses, ListPiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks',
    ...options
});

/**
 * Store a new piggy bank
 *
 * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storePiggyBank = <ThrowOnError extends boolean = false>(options: Options<StorePiggyBankData, ThrowOnError>) => (options.client ?? client).post<StorePiggyBankResponses, StorePiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a piggy bank.
 *
 * Delete a piggy bank.
 */
export const deletePiggyBank = <ThrowOnError extends boolean = false>(options: Options<DeletePiggyBankData, ThrowOnError>) => (options.client ?? client).delete<DeletePiggyBankResponses, DeletePiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks/{id}',
    ...options
});

/**
 * Get a single piggy bank.
 *
 * Get a single piggy bank.
 */
export const getPiggyBank = <ThrowOnError extends boolean = false>(options: Options<GetPiggyBankData, ThrowOnError>) => (options.client ?? client).get<GetPiggyBankResponses, GetPiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks/{id}',
    ...options
});

/**
 * Update existing piggy bank.
 *
 * Update existing piggy bank.
 */
export const updatePiggyBank = <ThrowOnError extends boolean = false>(options: Options<UpdatePiggyBankData, ThrowOnError>) => (options.client ?? client).put<UpdatePiggyBankResponses, UpdatePiggyBankErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/piggy-banks/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all transactions created by a recurring transaction.
 *
 * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
 */
export const listTransactionByRecurrence = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByRecurrenceData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByRecurrenceResponses, ListTransactionByRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences/{id}/transactions',
    ...options
});

/**
 * List all recurring transactions.
 *
 * List all recurring transactions.
 */
export const listRecurrence = <ThrowOnError extends boolean = false>(options?: Options<ListRecurrenceData, ThrowOnError>) => (options?.client ?? client).get<ListRecurrenceResponses, ListRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences',
    ...options
});

/**
 * Store a new recurring transaction
 *
 * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeRecurrence = <ThrowOnError extends boolean = false>(options: Options<StoreRecurrenceData, ThrowOnError>) => (options.client ?? client).post<StoreRecurrenceResponses, StoreRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a recurring transaction.
 *
 * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
 */
export const deleteRecurrence = <ThrowOnError extends boolean = false>(options: Options<DeleteRecurrenceData, ThrowOnError>) => (options.client ?? client).delete<DeleteRecurrenceResponses, DeleteRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences/{id}',
    ...options
});

/**
 * Get a single recurring transaction.
 *
 * Get a single recurring transaction.
 */
export const getRecurrence = <ThrowOnError extends boolean = false>(options: Options<GetRecurrenceData, ThrowOnError>) => (options.client ?? client).get<GetRecurrenceResponses, GetRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences/{id}',
    ...options
});

/**
 * Update existing recurring transaction.
 *
 * Update existing recurring transaction.
 */
export const updateRecurrence = <ThrowOnError extends boolean = false>(options: Options<UpdateRecurrenceData, ThrowOnError>) => (options.client ?? client).put<UpdateRecurrenceResponses, UpdateRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Trigger the creation of a transaction for a specific recurring transaction
 *
 * Trigger the creation of a transaction for a specific recurring transaction. All recurrences have a set of future occurrences. For those moments, you can trigger the creation of the transaction. That means the transaction will be created NOW, instead of on the indicated date. The transaction will be dated to _today_.
 *
 * So, if you recurring transaction that occurs every Monday, you can trigger the creation of a transaction for Monday in two weeks, today. On that Monday two weeks from now, no transaction will be created. Instead, the transaction is created right now, and dated _today_.
 *
 */
export const triggerRecurrenceRecurrence = <ThrowOnError extends boolean = false>(options: Options<TriggerRecurrenceRecurrenceData, ThrowOnError>) => (options.client ?? client).post<TriggerRecurrenceRecurrenceResponses, TriggerRecurrenceRecurrenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/recurrences/{id}/trigger',
    ...options
});

/**
 * List rules in this rule group.
 *
 * List rules in this rule group.
 */
export const listRuleByGroup = <ThrowOnError extends boolean = false>(options: Options<ListRuleByGroupData, ThrowOnError>) => (options.client ?? client).get<ListRuleByGroupResponses, ListRuleByGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}/rules',
    ...options
});

/**
 * Test which transactions would be hit by the rule group. No changes will be made.
 *
 * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
 */
export const testRuleGroup = <ThrowOnError extends boolean = false>(options: Options<TestRuleGroupData, ThrowOnError>) => (options.client ?? client).get<TestRuleGroupResponses, TestRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}/test',
    ...options
});

/**
 * Fire the rule group on your transactions.
 *
 * Fire the rule group on your transactions. Changes will be made by the rules in the rule group. Limit the result if you want to.
 */
export const fireRuleGroup = <ThrowOnError extends boolean = false>(options: Options<FireRuleGroupData, ThrowOnError>) => (options.client ?? client).post<FireRuleGroupResponses, FireRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}/trigger',
    ...options
});

/**
 * List all rule groups.
 *
 * List all rule groups.
 */
export const listRuleGroup = <ThrowOnError extends boolean = false>(options?: Options<ListRuleGroupData, ThrowOnError>) => (options?.client ?? client).get<ListRuleGroupResponses, ListRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups',
    ...options
});

/**
 * Store a new rule group.
 *
 * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeRuleGroup = <ThrowOnError extends boolean = false>(options: Options<StoreRuleGroupData, ThrowOnError>) => (options.client ?? client).post<StoreRuleGroupResponses, StoreRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a rule group.
 *
 * Delete a rule group.
 */
export const deleteRuleGroup = <ThrowOnError extends boolean = false>(options: Options<DeleteRuleGroupData, ThrowOnError>) => (options.client ?? client).delete<DeleteRuleGroupResponses, DeleteRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}',
    ...options
});

/**
 * Get a single rule group.
 *
 * Get a single rule group. This does not include the rules. For that, see below.
 */
export const getRuleGroup = <ThrowOnError extends boolean = false>(options: Options<GetRuleGroupData, ThrowOnError>) => (options.client ?? client).get<GetRuleGroupResponses, GetRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}',
    ...options
});

/**
 * Update existing rule group.
 *
 * Update existing rule group.
 */
export const updateRuleGroup = <ThrowOnError extends boolean = false>(options: Options<UpdateRuleGroupData, ThrowOnError>) => (options.client ?? client).put<UpdateRuleGroupResponses, UpdateRuleGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rule-groups/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Test which transactions would be hit by the rule. No changes will be made.
 *
 * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
 */
export const testRule = <ThrowOnError extends boolean = false>(options: Options<TestRuleData, ThrowOnError>) => (options.client ?? client).get<TestRuleResponses, TestRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules/{id}/test',
    ...options
});

/**
 * Fire the rule on your transactions.
 *
 * Fire the rule group on your transactions. Changes will be made by the rules in the group. Limit the result if you want to.
 */
export const fireRule = <ThrowOnError extends boolean = false>(options: Options<FireRuleData, ThrowOnError>) => (options.client ?? client).post<FireRuleResponses, FireRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules/{id}/trigger',
    ...options
});

/**
 * List all rules.
 *
 * List all rules.
 */
export const listRule = <ThrowOnError extends boolean = false>(options?: Options<ListRuleData, ThrowOnError>) => (options?.client ?? client).get<ListRuleResponses, ListRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules',
    ...options
});

/**
 * Store a new rule
 *
 * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeRule = <ThrowOnError extends boolean = false>(options: Options<StoreRuleData, ThrowOnError>) => (options.client ?? client).post<StoreRuleResponses, StoreRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete an rule.
 *
 * Delete an rule.
 */
export const deleteRule = <ThrowOnError extends boolean = false>(options: Options<DeleteRuleData, ThrowOnError>) => (options.client ?? client).delete<DeleteRuleResponses, DeleteRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules/{id}',
    ...options
});

/**
 * Get a single rule.
 *
 * Get a single rule.
 */
export const getRule = <ThrowOnError extends boolean = false>(options: Options<GetRuleData, ThrowOnError>) => (options.client ?? client).get<GetRuleResponses, GetRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules/{id}',
    ...options
});

/**
 * Update existing rule.
 *
 * Update existing rule.
 */
export const updateRule = <ThrowOnError extends boolean = false>(options: Options<UpdateRuleData, ThrowOnError>) => (options.client ?? client).put<UpdateRuleResponses, UpdateRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/rules/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Lists all attachments.
 *
 * Lists all attachments.
 */
export const listAttachmentByTag = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByTagData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByTagResponses, ListAttachmentByTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags/{tag}/attachments',
    ...options
});

/**
 * List all transactions with this tag.
 *
 * List all transactions with this tag.
 */
export const listTransactionByTag = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByTagData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByTagResponses, ListTransactionByTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags/{tag}/transactions',
    ...options
});

/**
 * List all tags.
 *
 * List all of the user's tags.
 */
export const listTag = <ThrowOnError extends boolean = false>(options?: Options<ListTagData, ThrowOnError>) => (options?.client ?? client).get<ListTagResponses, ListTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags',
    ...options
});

/**
 * Store a new tag
 *
 * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeTag = <ThrowOnError extends boolean = false>(options: Options<StoreTagData, ThrowOnError>) => (options.client ?? client).post<StoreTagResponses, StoreTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete an tag.
 *
 * Delete an tag.
 */
export const deleteTag = <ThrowOnError extends boolean = false>(options: Options<DeleteTagData, ThrowOnError>) => (options.client ?? client).delete<DeleteTagResponses, DeleteTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags/{tag}',
    ...options
});

/**
 * Get a single tag.
 *
 * Get a single tag.
 */
export const getTag = <ThrowOnError extends boolean = false>(options: Options<GetTagData, ThrowOnError>) => (options.client ?? client).get<GetTagResponses, GetTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags/{tag}',
    ...options
});

/**
 * Update existing tag.
 *
 * Update existing tag.
 */
export const updateTag = <ThrowOnError extends boolean = false>(options: Options<UpdateTagData, ThrowOnError>) => (options.client ?? client).put<UpdateTagResponses, UpdateTagErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/tags/{tag}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all accounts with this currency.
 *
 * List all accounts with this currency.
 */
export const listAccountByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListAccountByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListAccountByCurrencyResponses, ListAccountByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/accounts',
    ...options
});

/**
 * List all available budgets with this currency.
 *
 * List all available budgets with this currency.
 */
export const listAvailableBudgetByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListAvailableBudgetByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListAvailableBudgetByCurrencyResponses, ListAvailableBudgetByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/available-budgets',
    ...options
});

/**
 * List all bills with this currency.
 *
 * List all bills with this currency.
 */
export const listBillByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListBillByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListBillByCurrencyResponses, ListBillByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/bills',
    ...options
});

/**
 * List all budget limits with this currency
 *
 * List all budget limits with this currency
 */
export const listBudgetLimitByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListBudgetLimitByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListBudgetLimitByCurrencyResponses, ListBudgetLimitByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/budget-limits',
    ...options
});

/**
 * List all recurring transactions with this currency.
 *
 * List all recurring transactions with this currency.
 */
export const listRecurrenceByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListRecurrenceByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListRecurrenceByCurrencyResponses, ListRecurrenceByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/recurrences',
    ...options
});

/**
 * List all rules with this currency.
 *
 * List all rules with this currency.
 */
export const listRuleByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListRuleByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListRuleByCurrencyResponses, ListRuleByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/rules',
    ...options
});

/**
 * List all transactions with this currency.
 *
 * List all transactions with this currency.
 */
export const listTransactionByCurrency = <ThrowOnError extends boolean = false>(options: Options<ListTransactionByCurrencyData, ThrowOnError>) => (options.client ?? client).get<ListTransactionByCurrencyResponses, ListTransactionByCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/transactions',
    ...options
});

/**
 * List all currencies.
 *
 * List all currencies.
 */
export const listCurrency = <ThrowOnError extends boolean = false>(options?: Options<ListCurrencyData, ThrowOnError>) => (options?.client ?? client).get<ListCurrencyResponses, ListCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies',
    ...options
});

/**
 * Store a new currency
 *
 * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeCurrency = <ThrowOnError extends boolean = false>(options: Options<StoreCurrencyData, ThrowOnError>) => (options.client ?? client).post<StoreCurrencyResponses, StoreCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Enable a single currency.
 *
 * Enable a single currency.
 */
export const enableCurrency = <ThrowOnError extends boolean = false>(options: Options<EnableCurrencyData, ThrowOnError>) => (options.client ?? client).post<EnableCurrencyResponses, EnableCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/enable',
    ...options
});

/**
 * Disable a currency.
 *
 * Disable a currency.
 */
export const disableCurrency = <ThrowOnError extends boolean = false>(options: Options<DisableCurrencyData, ThrowOnError>) => (options.client ?? client).post<DisableCurrencyResponses, DisableCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/disable',
    ...options
});

/**
 * Make currency primary currency.
 *
 * Make this currency the primary currency for the current financial administration. If the currency is not enabled, it will be enabled as well.
 */
export const primaryCurrency = <ThrowOnError extends boolean = false>(options: Options<PrimaryCurrencyData, ThrowOnError>) => (options.client ?? client).post<PrimaryCurrencyResponses, PrimaryCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}/primary',
    ...options
});

/**
 * Delete a currency.
 *
 * Delete a currency.
 */
export const deleteCurrency = <ThrowOnError extends boolean = false>(options: Options<DeleteCurrencyData, ThrowOnError>) => (options.client ?? client).delete<DeleteCurrencyResponses, DeleteCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}',
    ...options
});

/**
 * Get a single currency.
 *
 * Get a single currency.
 */
export const getCurrency = <ThrowOnError extends boolean = false>(options: Options<GetCurrencyData, ThrowOnError>) => (options.client ?? client).get<GetCurrencyResponses, GetCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}',
    ...options
});

/**
 * Update existing currency.
 *
 * Update existing currency.
 */
export const updateCurrency = <ThrowOnError extends boolean = false>(options: Options<UpdateCurrencyData, ThrowOnError>) => (options.client ?? client).put<UpdateCurrencyResponses, UpdateCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/{code}',
    ...options,
    headers: {
        'Content-Type': 'application/vnd.api+json',
        ...options.headers
    }
});

/**
 * Get the primary currency of the current administration.
 *
 * Get the primary currency of the current administration. This replaces what was called "the user's default currency" although they are essentially the same.
 */
export const getPrimaryCurrency = <ThrowOnError extends boolean = false>(options?: Options<GetPrimaryCurrencyData, ThrowOnError>) => (options?.client ?? client).get<GetPrimaryCurrencyResponses, GetPrimaryCurrencyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/currencies/primary',
    ...options
});

/**
 * Lists all the transaction links for an individual journal (individual split).
 *
 * Lists all the transaction links for an individual journal (a split). Don't use the group ID, you need the actual underlying journal (the split).
 */
export const listLinksByJournal = <ThrowOnError extends boolean = false>(options: Options<ListLinksByJournalData, ThrowOnError>) => (options.client ?? client).get<ListLinksByJournalResponses, ListLinksByJournalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-journals/{id}/links',
    ...options
});

/**
 * Delete split from transaction
 *
 * Delete an individual journal (split) from a transaction.
 */
export const deleteTransactionJournal = <ThrowOnError extends boolean = false>(options: Options<DeleteTransactionJournalData, ThrowOnError>) => (options.client ?? client).delete<DeleteTransactionJournalResponses, DeleteTransactionJournalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-journals/{id}',
    ...options
});

/**
 * Get a single transaction, based on one of the underlying transaction journals (transaction splits).
 *
 * Get a single transaction by underlying journal (split).
 */
export const getTransactionByJournal = <ThrowOnError extends boolean = false>(options: Options<GetTransactionByJournalData, ThrowOnError>) => (options.client ?? client).get<GetTransactionByJournalResponses, GetTransactionByJournalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transaction-journals/{id}',
    ...options
});

/**
 * Lists all attachments.
 *
 * Lists all attachments.
 */
export const listAttachmentByTransaction = <ThrowOnError extends boolean = false>(options: Options<ListAttachmentByTransactionData, ThrowOnError>) => (options.client ?? client).get<ListAttachmentByTransactionResponses, ListAttachmentByTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions/{id}/attachments',
    ...options
});

/**
 * Lists all piggy bank events.
 *
 * Lists all piggy bank events.
 */
export const listEventByTransaction = <ThrowOnError extends boolean = false>(options: Options<ListEventByTransactionData, ThrowOnError>) => (options.client ?? client).get<ListEventByTransactionResponses, ListEventByTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions/{id}/piggy-bank-events',
    ...options
});

/**
 * List all the user's transactions.
 *
 *
 * List all the user's transactions.
 */
export const listTransaction = <ThrowOnError extends boolean = false>(options?: Options<ListTransactionData, ThrowOnError>) => (options?.client ?? client).get<ListTransactionResponses, ListTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions',
    ...options
});

/**
 * Store a new transaction
 *
 * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
 */
export const storeTransaction = <ThrowOnError extends boolean = false>(options: Options<StoreTransactionData, ThrowOnError>) => (options.client ?? client).post<StoreTransactionResponses, StoreTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a transaction.
 *
 * Delete a transaction.
 */
export const deleteTransaction = <ThrowOnError extends boolean = false>(options: Options<DeleteTransactionData, ThrowOnError>) => (options.client ?? client).delete<DeleteTransactionResponses, DeleteTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions/{id}',
    ...options
});

/**
 * Get a single transaction.
 *
 * Get a single transaction.
 */
export const getTransaction = <ThrowOnError extends boolean = false>(options: Options<GetTransactionData, ThrowOnError>) => (options.client ?? client).get<GetTransactionResponses, GetTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions/{id}',
    ...options
});

/**
 * Update existing transaction. For more information, see https://docs.firefly-iii.org/references/firefly-iii/api/specials/
 *
 * Update an existing transaction.
 */
export const updateTransaction = <ThrowOnError extends boolean = false>(options: Options<UpdateTransactionData, ThrowOnError>) => (options.client ?? client).put<UpdateTransactionResponses, UpdateTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/transactions/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all the user groups available to this user.
 *
 *
 * List all the user groups available to this user. These are essentially the 'financial administrations' that Firefly III supports.
 */
export const listUserGroups = <ThrowOnError extends boolean = false>(options?: Options<ListUserGroupsData, ThrowOnError>) => (options?.client ?? client).get<ListUserGroupsResponses, ListUserGroupsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/user-groups',
    ...options
});

/**
 * Get a single user group.
 *
 * Returns a single user group by its ID.
 *
 */
export const getUserGroup = <ThrowOnError extends boolean = false>(options: Options<GetUserGroupData, ThrowOnError>) => (options.client ?? client).get<GetUserGroupResponses, GetUserGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/user-groups/{id}',
    ...options
});

/**
 * Update an existing user group.
 *
 * Used to update a single user group. The available fields are still limited.
 *
 */
export const updateUserGroup = <ThrowOnError extends boolean = false>(options: Options<UpdateUserGroupData, ThrowOnError>) => (options.client ?? client).put<UpdateUserGroupResponses, UpdateUserGroupErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/user-groups/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Search for accounts
 *
 * Search for accounts
 */
export const searchAccounts = <ThrowOnError extends boolean = false>(options: Options<SearchAccountsData, ThrowOnError>) => (options.client ?? client).get<SearchAccountsResponses, SearchAccountsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/search/accounts',
    ...options
});

/**
 * Search for transactions
 *
 * Searches through the users transactions.
 */
export const searchTransactions = <ThrowOnError extends boolean = false>(options: Options<SearchTransactionsData, ThrowOnError>) => (options.client ?? client).get<SearchTransactionsResponses, SearchTransactionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/search/transactions',
    ...options
});

/**
 * Returns basic sums of the users data.
 *
 * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard.
 *
 */
export const getBasicSummary = <ThrowOnError extends boolean = false>(options: Options<GetBasicSummaryData, ThrowOnError>) => (options.client ?? client).get<GetBasicSummaryResponses, GetBasicSummaryErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/summary/basic',
    ...options
});

/**
 * System information end point.
 *
 * Returns general system information and versions of the (supporting) software.
 *
 */
export const getAbout = <ThrowOnError extends boolean = false>(options?: Options<GetAboutData, ThrowOnError>) => (options?.client ?? client).get<GetAboutResponses, GetAboutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/about',
    ...options
});

/**
 * Currently authenticated user endpoint.
 *
 * Returns the currently authenticated user.
 *
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>) => (options?.client ?? client).get<GetCurrentUserResponses, GetCurrentUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/about/user',
    ...options
});

/**
 * Get Firefly III system configuration values.
 *
 * Returns all editable and not-editable configuration values for this Firefly III installation
 */
export const getConfiguration = <ThrowOnError extends boolean = false>(options?: Options<GetConfigurationData, ThrowOnError>) => (options?.client ?? client).get<GetConfigurationResponses, GetConfigurationErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/configuration',
    ...options
});

/**
 * Get a single Firefly III system configuration value
 *
 * Returns one configuration variable for this Firefly III installation
 */
export const getSingleConfiguration = <ThrowOnError extends boolean = false>(options: Options<GetSingleConfigurationData, ThrowOnError>) => (options.client ?? client).get<GetSingleConfigurationResponses, GetSingleConfigurationErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/configuration/{name}',
    ...options
});

/**
 * Update configuration value
 *
 * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
 */
export const setConfiguration = <ThrowOnError extends boolean = false>(options: Options<SetConfigurationData, ThrowOnError>) => (options.client ?? client).put<SetConfigurationResponses, SetConfigurationErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/configuration/{name}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Cron job endpoint
 *
 * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint
 * to run the cron. The cron requires the CLI token to be present. The cron job will fire for all
 * users.
 *
 */
export const getCron = <ThrowOnError extends boolean = false>(options: Options<GetCronData, ThrowOnError>) => (options.client ?? client).get<GetCronResponses, GetCronErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/cron/{cliToken}',
    ...options
});

/**
 * List all users.
 *
 * List all the users in this instance of Firefly III.
 */
export const listUser = <ThrowOnError extends boolean = false>(options?: Options<ListUserData, ThrowOnError>) => (options?.client ?? client).get<ListUserResponses, ListUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/users',
    ...options
});

/**
 * Store a new user
 *
 * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the "forgot password" function.
 *
 */
export const storeUser = <ThrowOnError extends boolean = false>(options: Options<StoreUserData, ThrowOnError>) => (options.client ?? client).post<StoreUserResponses, StoreUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/users',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a user.
 *
 * Delete a user. You cannot delete the user you're authenticated with. This cannot be undone. Be careful.
 */
export const deleteUser = <ThrowOnError extends boolean = false>(options: Options<DeleteUserData, ThrowOnError>) => (options.client ?? client).delete<DeleteUserResponses, DeleteUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/users/{id}',
    ...options
});

/**
 * Get a single user.
 *
 * Gets all info of a single user.
 */
export const getUser = <ThrowOnError extends boolean = false>(options: Options<GetUserData, ThrowOnError>) => (options.client ?? client).get<GetUserResponses, GetUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/users/{id}',
    ...options
});

/**
 * Update an existing user's information.
 *
 * Update existing user.
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => (options.client ?? client).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/users/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all users preferences.
 *
 * List all of the preferences of the user.
 */
export const listPreference = <ThrowOnError extends boolean = false>(options?: Options<ListPreferenceData, ThrowOnError>) => (options?.client ?? client).get<ListPreferenceResponses, ListPreferenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/preferences',
    ...options
});

/**
 * Store a new preference for this user.
 *
 * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
 */
export const storePreference = <ThrowOnError extends boolean = false>(options: Options<StorePreferenceData, ThrowOnError>) => (options.client ?? client).post<StorePreferenceResponses, StorePreferenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/preferences',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Return a single preference.
 *
 * Return a single preference and the value.
 */
export const getPreference = <ThrowOnError extends boolean = false>(options: Options<GetPreferenceData, ThrowOnError>) => (options.client ?? client).get<GetPreferenceResponses, GetPreferenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/preferences/{name}',
    ...options
});

/**
 * Update preference
 *
 * Update a user's preference.
 */
export const updatePreference = <ThrowOnError extends boolean = false>(options: Options<UpdatePreferenceData, ThrowOnError>) => (options.client ?? client).put<UpdatePreferenceResponses, UpdatePreferenceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/preferences/{name}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get all the messages of a single webhook.
 *
 * When a webhook is triggered the actual message that will be send is stored in a "message". You can view and analyse these messages.
 */
export const getWebhookMessages = <ThrowOnError extends boolean = false>(options: Options<GetWebhookMessagesData, ThrowOnError>) => (options.client ?? client).get<GetWebhookMessagesResponses, GetWebhookMessagesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages',
    ...options
});

/**
 * Delete a webhook message.
 *
 * Delete a webhook message. Any time a webhook is triggered the message is stored before it's sent. You can delete them before or after sending.
 */
export const deleteWebhookMessage = <ThrowOnError extends boolean = false>(options: Options<DeleteWebhookMessageData, ThrowOnError>) => (options.client ?? client).delete<DeleteWebhookMessageResponses, DeleteWebhookMessageErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages/{messageId}',
    ...options
});

/**
 * Get a single message from a webhook.
 *
 * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
 */
export const getSingleWebhookMessage = <ThrowOnError extends boolean = false>(options: Options<GetSingleWebhookMessageData, ThrowOnError>) => (options.client ?? client).get<GetSingleWebhookMessageResponses, GetSingleWebhookMessageErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages/{messageId}',
    ...options
});

/**
 * Get all the failed attempts of a single webhook message.
 *
 * When a webhook message fails to send it will store the failure in an "attempt". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
 */
export const getWebhookMessageAttempts = <ThrowOnError extends boolean = false>(options: Options<GetWebhookMessageAttemptsData, ThrowOnError>) => (options.client ?? client).get<GetWebhookMessageAttemptsResponses, GetWebhookMessageAttemptsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts',
    ...options
});

/**
 * Delete a webhook attempt.
 *
 * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
 */
export const deleteWebhookMessageAttempt = <ThrowOnError extends boolean = false>(options: Options<DeleteWebhookMessageAttemptData, ThrowOnError>) => (options.client ?? client).delete<DeleteWebhookMessageAttemptResponses, DeleteWebhookMessageAttemptErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}',
    ...options
});

/**
 * Get a single failed attempt from a single webhook message.
 *
 * When a webhook message fails to send it will store the failure in an "attempt". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
 */
export const getSingleWebhookMessageAttempt = <ThrowOnError extends boolean = false>(options: Options<GetSingleWebhookMessageAttemptData, ThrowOnError>) => (options.client ?? client).get<GetSingleWebhookMessageAttemptResponses, GetSingleWebhookMessageAttemptErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}',
    ...options
});

/**
 * Submit messages for a webhook.
 *
 * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can't see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
 */
export const submitWebhook = <ThrowOnError extends boolean = false>(options: Options<SubmitWebhookData, ThrowOnError>) => (options.client ?? client).post<SubmitWebhookResponses, SubmitWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/submit',
    ...options
});

/**
 * Trigger webhook for a given transaction.
 *
 * This endpoint will execute this webhook for a given transaction ID. This is an asynchronous operation, so you can't see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
 */
export const triggerTransactionWebhook = <ThrowOnError extends boolean = false>(options: Options<TriggerTransactionWebhookData, ThrowOnError>) => (options.client ?? client).post<TriggerTransactionWebhookResponses, TriggerTransactionWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}/trigger-transaction/{transactionId}',
    ...options
});

/**
 * List all webhooks.
 *
 * List all the user's webhooks.
 */
export const listWebhook = <ThrowOnError extends boolean = false>(options?: Options<ListWebhookData, ThrowOnError>) => (options?.client ?? client).get<ListWebhookResponses, ListWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks',
    ...options
});

/**
 * Store a new webhook
 *
 * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
 *
 */
export const storeWebhook = <ThrowOnError extends boolean = false>(options: Options<StoreWebhookData, ThrowOnError>) => (options.client ?? client).post<StoreWebhookResponses, StoreWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a webhook.
 *
 * Delete a webhook.
 */
export const deleteWebhook = <ThrowOnError extends boolean = false>(options: Options<DeleteWebhookData, ThrowOnError>) => (options.client ?? client).delete<DeleteWebhookResponses, DeleteWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}',
    ...options
});

/**
 * Get a single webhook.
 *
 * Gets all info of a single webhook.
 */
export const getWebhook = <ThrowOnError extends boolean = false>(options: Options<GetWebhookData, ThrowOnError>) => (options.client ?? client).get<GetWebhookResponses, GetWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}',
    ...options
});

/**
 * Update existing webhook.
 *
 * Update an existing webhook's information. If you wish to reset the secret, submit any value as the "secret". Firefly III will take this as a hint and reset the secret of the webhook.
 */
export const updateWebhook = <ThrowOnError extends boolean = false>(options: Options<UpdateWebhookData, ThrowOnError>) => (options.client ?? client).put<UpdateWebhookResponses, UpdateWebhookErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, { scheme: 'bearer', type: 'http' }],
    url: '/v1/webhooks/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});
